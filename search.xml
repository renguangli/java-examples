<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[DDOS攻击的防范教程]]></title>
    <url>%2Farticle%2Fddos.html</url>
    <content type="text"><![CDATA[转载自 阮一峰的网络日志 一个多月前，阮一峰老师的个人网站遭受 DDOS 攻击，下线了50多个小时。这篇文章就来谈谈，如何应对这种攻击。 需要说明的是，我对 DDOS 并不精通，从没想过自己会成为攻击目标。攻击发生以后，很多素昧平生的朋友提供了各种帮助和建议，让我学到了很多东西。这里记录的就是对我最有帮助的一些解决方案。 一、DDOS 是什么？首先，我来解释一下，DDOS 是什么。 举例来说，我开了一家餐厅，正常情况下，最多可以容纳30个人同时进餐。你直接走进餐厅，找一张桌子坐下点餐，马上就可以吃到东西。 很不幸，我得罪了一个流氓。他派出300个人同时涌进餐厅。这些人看上去跟正常的顾客一样，每个都说”赶快上餐”。但是，餐厅的容量只有30个人，根本不可能同时满足这么多的点餐需求，加上他们把门口都堵死了，里三层外三层，正常用餐的客人根本进不来，实际上就把餐厅瘫痪了。 这就是 DDOS 攻击，它在短时间内发起大量请求，耗尽服务器的资源，无法响应正常的访问，造成网站实质下线 DDOS 里面的 DOS 是 denial of service（停止服务）的缩写，表示这种攻击的目的，就是使得服务中断。最前面的那个 D 是 distributed （分布式），表示攻击不是来自一个地方，而是来自四面八方，因此更难防。你关了前门，他从后门进来；你关了后门，他从窗口跳起来。 二、DDOS 的种类DDOS 不是一种攻击，而是一大类攻击的总称。它有几十种类型，新的攻击方法还在不断发明出来。网站运行的各个环节，都可以是攻击目标。只要把一个环节攻破，使得整个流程跑不起来，就达到了瘫痪服务的目的。 其中，比较常见的一种攻击是 cc 攻击。它就是简单粗暴地送来大量正常的请求，超出服务器的最大承受量，导致宕机。我遭遇的就是 cc 攻击，最多的时候全世界大概20多个 IP 地址轮流发出请求，每个地址的请求量在每秒200次~300次。我看访问日志的时候，就觉得那些请求像洪水一样涌来，一眨眼就是一大堆，几分钟的时间，日志文件的体积就大了100MB。说实话，这只能算小攻击，但是我的个人网站没有任何防护，服务器还是跟其他人共享的，这种流量一来立刻就下线了。 本文以下的内容都是针对 cc 攻击。 三、备份网站防范 DDOS 的第一步，就是你要有一个备份网站，或者最低限度有一个临时主页。生产服务器万一下线了，可以立刻切换到备份网站，不至于毫无办法。 备份网站不一定是全功能的，如果能做到全静态浏览，就能满足需求。最低限度应该可以显示公告，告诉用户，网站出了问题，正在全力抢修。我的个人网站下线的时候，我就做了一个临时主页，很简单的几行 HTML 代码。 这种临时主页建议放到 Github Pages 或者 Netlify，它们的带宽大，可以应对攻击，而且都支持绑定域名，还能从源码自动构建。 四、HTTP 请求的拦截如果恶意请求有特征，对付起来很简单：直接拦截它就行了 HTTP 请求的特征一般有两种：IP 地址和 User Agent 字段。比如，恶意请求都是从某个 IP 段发出的，那么把这个 IP 段封掉就行了。或者，它们的 User Agent 字段有特征（包含某个特定的词语），那就把带有这个词语的请求拦截。 拦截可以在三个层次做。 （1）专用硬件Web 服务器的前面可以架设硬件防火墙，专门过滤请求。这种效果最好，但是价格也最贵 ### （2）本机防火墙 操作系统都带有软件防火墙，Linux 服务器一般使用 iptables。比如，拦截 IP 地址1.2.3.4的请求，可以执行下面的命令。 1iptables -A INPUT -s 1.2.3.4 -j DROP iptables 比较复杂，我也不太会用。它对服务器性能有一定影响，也防不住大型攻击。 （3）Web 服务器Web 服务器也可以过滤请求。拦截 IP 地址1.2.3.4，nginx 的写法如下。 123location / &#123; deny 1.2.3.4;&#125; Apache 的写法是在.htaccess文件里面，加上下面一段。 123&lt;RequireAll&gt; Require all granted Require not ip 1.2.3.4&lt;/RequireAll&gt; 如果想要更精确的控制（比如自动识别并拦截那些频繁请求的 IP 地址），就要用到 WAF。这里就不详细介绍了，nginx 这方面的设置可以参考这里和这里。 Web 服务器的拦截非常消耗性能，尤其是 Apache。稍微大一点的攻击，这种方法就没用了。 五、带宽扩容上一节的 HTTP 拦截有一个前提，就是请求必须有特征。但是，真正的 DDOS 攻击是没有特征的，它的请求看上去跟正常请求一样，而且来自不同的 IP 地址，所以没法拦截。这就是为什么 DDOS 特别难防的原因。 当然，这样的 DDOS 攻击的成本不低，普通的网站不会有这种待遇。不过，真要遇到了该怎么办呢，有没有根本性的防范方法呢？ 答案很简单，就是设法把这些请求都消化掉。30个人的餐厅来了300人，那就想办法把餐厅扩大（比如临时再租一个门面，并请一些厨师），让300个人都能坐下，那么就不影响正常的用户了。对于网站来说，就是在短时间内急剧扩容，提供几倍或几十倍的带宽，顶住大流量的请求。这就是为什么云服务商可以提供防护产品，因为他们有大量冗余带宽，可以用来消化 DDOS 攻击。 一个朋友传授了一个方法，给我留下深刻印象。某云服务商承诺，每个主机保 5G 流量以下的攻击，他们就一口气买了5个。网站架设在其中一个主机上面，但是不暴露给用户，其他主机都是镜像，用来面对用户，DNS 会把访问量均匀分配到这四台镜像服务器。一旦出现攻击，这种架构就可以防住 20G 的流量，如果有更大的攻击，那就买更多的临时主机，不断扩容镜像。 六、CDNCDN 指的是网站的静态内容分发到多个服务器，用户就近访问，提高速度。因此，CDN 也是带宽扩容的一种方法，可以用来防御 DDOS 攻击。 网站内容存放在源服务器，CDN 上面是内容的缓存。用户只允许访问 CDN，如果内容不在 CDN 上，CDN 再向源服务器发出请求。这样的话，只要 CDN 够大，就可以抵御很大的攻击。不过，这种方法有一个前提，网站的大部分内容必须可以静态缓存。对于动态内容为主的网站（比如论坛），就要想别的办法，尽量减少用户对动态数据的请求。 上一节提到的镜像服务器，本质就是自己搭建一个微型 CDN。各大云服务商提供的高防 IP，背后也是这样做的：网站域名指向高防 IP，它提供一个缓冲层，清洗流量，并对源服务器的内容进行缓存。 这里有一个关键点，一旦上了 CDN，千万不要泄露源服务器的 IP 地址，否则攻击者可以绕过 CDN 直接攻击源服务器，前面的努力都白费。搜一下”绕过 CDN 获取真实 IP 地址”，你就会知道国内的黑产行业有多猖獗。 cloudflare 是一个免费 CDN 服务，并提供防火墙，高度推荐。我还要感谢 v2ex.com 的站长 @livid 热情提供帮助，我现在用的就是他们的 CDN 产品。]]></content>
      <categories>
        <category>安全</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[docker入门之Dockerfile]]></title>
    <url>%2Farticle%2Fdockerfile.html</url>
    <content type="text"><![CDATA[我们可以使用Dockerfile创建镜像，下面对Dockerfile指令进行简单介绍。 FROMFROM指定基础镜像，若镜像不存在Docker会从docker hub中 来查找该镜像。FROM命令必须是Dockerfile的首个命令。 1FROM centos:7.2.1511 MAINTAINER维护者信息,一般用来指定作者,紧跟FROM命令 1MAINTAINER Ren Guangli &lt;renguangli@bonc.com.cn&gt; ADDDockerfile中的COPY指令和ADD指令都可以将主机上的资源复制或加入到容器镜像中，都是在构建镜像的过程中完成的。ADD指令不仅能够将构建命令所在的主机本地的文件或目录，而且能够将远程URL所对应的文件或目录，作为资源复制到镜像文件系统。如果源文件是identity, gzip, bzip2，xz，tar.gz，tgz等类型的压缩文件，会添加tar -x命令，自动解压 对于从远程URL获取资源的情况，由于ADD指令不支持认证，如果从远程获取资源需要认证，则只能使用RUN wget或RUN curl替代。另外，如果源路径的资源发生变化，则该ADD指令将使Docker Cache失效，Dockerfile中后续的所有指令都不能使用缓存。因此尽量将ADD指令放在Dockerfile的后面。 123# exec格式用法ADD [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;]ADD [&quot;hello.sh&quot;,&quot;docker.sh&quot;,&quot;/mnt&quot;] 适合路径中带有空格的情况123# shell格式用法ADD &lt;src&gt;... &lt;dest&gt;ADD hello.sh docker.sh /mnt 注意事项 源路径可以有多个 源路径是相对于执行build的相对路径 源路径如果是本地路径，必须是build上下文中的路径 源路径如果是一个目录，则该目录下的所有内容都将被加入到容器，但是该目录本身不会 目标路径必须是绝对路径，或相对于WORKDIR的相对路径 目标路径如果不存在，则会创建相应的完整路径 路径中可以使用通配符 COPY和ADD指令类似，只是不能从远端获取资源和自动解压压缩文件 ENV配置环境变量 12ENV &lt;key&gt; &lt;value&gt;ENV &lt;key&gt;=&lt;value&gt; ... 第二种格式可以设置多个键值对，推荐在一条ENV指令中设置多个键值对，因为这样产生一个缓存层。 1ENV JAVA_HOME=/mnt/jdk1.7 PATH=$JAVA_HOME/bin:$PATH CLASSPATH=.:$JAVA_HOME/lib EXPOSE1EXPOSE &lt;port&gt; [&lt;port&gt;...] 指定于外界交互的端口 1EXPOSE 8080 443 在容器启动时用-p传递参数，例如docker run -d -p 8088:8080 -p 8089:443 tomcat:7.0.81将容器内的8080绑定到本机的8088端口,443绑定到本机的8089端口 USER1USER root 指定运行容器时的用户名或 UID，后续的RUN、CMD、ENTRYPOINT也会使用指定用户。 WORKDIR1WORKDIR /path/to/workdir 为后续的RUN、CMD、ENTRYPOINT指令配置工作目录。可以使用多个WORKDIR指令，后续命令如果参数是相对路径，则会基于之前命令指定的路径 1234WORKDIR /aWORKDIR bWORKDIR cRUN pwd 最终路径是/a/b/c。 WORKDIR指令可以在ENV设置变量之后调用环境变量: 12ENV DIRPATH /pathWORKDIR $DIRPATH/$DIRNAME 最终路径则为 /path/$DIRNAME。 参考连接http://www.docker.org.cn/dockerppt/114.htmlhttp://www.cnblogs.com/sorex/p/6481407.htmlhttp://blog.csdn.net/taiyangdao/article/details/73222601]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker入门之容器]]></title>
    <url>%2Farticle%2Fdocker-container.html</url>
    <content type="text"><![CDATA[容器是docker的另一个核心概念，简单来说容器就是镜像的一个运行示例。 查看容器使用docker ps命令查看运行着的容器 123[root@localhost ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES229929eb660f renguangli/nginx:1.0 &quot;nginx -g &apos;daemon off&quot; 17 hours ago Up 3 seconds 0.0.0.0:80-&gt;80/tcp nginx 使用docker ps -a命令查看所有的容器 1234[root@localhost ~]# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES229929eb660f renguangli/nginx:1.0 &quot;nginx -g &apos;daemon off&quot; 17 hours ago Up 3 seconds 0.0.0.0:80-&gt;80/tcp nginx3ceb621f4aa9 jenkins &quot;/bin/tini -- /usr/lo&quot; About an hour ago Exited (137) 48 seconds ago elated_davinci 使用docker ps -q命令查看运行着的容器Id 使用docker create image:tag name命令创建一个容器并给容器一个name，例如 12[root@localhost ~]# docker create nginx:latest nginxfd47cedfcce5cd2879ef65b342b1cd4130cbcc081cec532ff7af1744ad589116 如果不加name的话随机分配一个名字 启动容器使用docker start 容器名称或容器ID来启动一个容器，例如 123[root@localhost ~]# docker ps -a229929eb660f renguangli/nginx:1.0 &quot;nginx -g &apos;daemon off&quot; 17 hours ago Exited (0) 8 seconds ago nginx[root@localhost ~]# docker start nginx 或者 docker start 229929eb660f 新建并启动容器创建容器后可以用docker start命令启动容器，也可以用docker run命令直接新建并启动容器，docker run相当于先执行docker create命令在执行docker start命令。例如，输出一个”hello docker” 12[root@localhost ~]# docker run ubuntu echo &quot;hello docker&quot;hello docker 这跟在本次执行echo &quot;hello docker&quot;几乎没有任何区别，但是在执行docker run命令时经历了复杂的操作： 检查本地是否存在指定的镜像，，不存在就从共有仓库下载 利用镜像创建并启动一个容器 分配一个文件系统给容器，并在只读的镜像层外面挂在一个可读写层 从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中 从王桥的地址池中配置一个IP地址给容器 执行用户指定的应用程序 执行完毕后容器自动终止 docker run -d命令会让容器在后台运行docker logs名利可以查看容器日志docker logs -f命令可以像tail -f命令一样查看容器日志 终止容器使用docker stop 容器名或容器ID命令停止一个容器 1234[root@localhost html]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES16555d4ebdf0 nginx:1.10.0 &quot;nginx -g &apos;daemon off&quot; 47 minutes ago Up 8 seconds 0.0.0.0:80-&gt;80/tcp jolly_goodall[root@localhost html]# docker stop 16555d4ebdf0 或者 docker stop jolly_goodall docker stop命令首先想容器发送SIGKILL的信号，等待一段时间后（默认10秒）在发送SIGKILL信号来终止容器docker kill 命令会直接发送SIGKILL信号来终止容器 终止的容器可以使用docer start来启动一个容器 运行着的容器可以使用docker restart来重启容器]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker入门之镜像]]></title>
    <url>%2Farticle%2Fdocker-image.html</url>
    <content type="text"><![CDATA[docker镜像类似于虚拟机镜像，可以将它理解为一个只读的模板。例如，一个镜像可以包含一个基本的操作系统，里面安装了tomcat(或者其它软件)，我们把它称为tomcat镜像。镜像是创建docker容器的基础。通过版本管理和增量的文件系统，docker提供了十分简单的机制来创建和更新的现有的镜像，也可以从镜像仓库里pull镜像，就像git pull代码一样。 获取镜像镜像是容器运行的前提条件，官方DockerHub 镜像仓库提供了很多个镜像提供大家开放下载。我们可以直接使用docker pull命令直接从Docker Hub镜像源下载镜像命令格式：docker pull name:tagname为镜像名称，tag为镜像的标签(通常用来表示版本信息)\获取一个Ubuntu 14.04系统镜像可以使用docker pull ubuntu:14.041[root@localhost ~]# docker pull ubuntu:14.04 如果不指定tag，则默认会选择latest标签，下载仓库中最新版本的镜像。严格地讲仓库名称还要添加镜像地址(即registry，注册服务器）为前缀，我们使用的是官方Docker Hub，所以前缀可以省略,完整命令为docker pull docker.io/library/ubuntu:14.04如果下载非官方的镜像，仓库名称前要指定完整的仓库地址。例如我们从网易的镜像源下载ubuntu 14.04 正确命令为 1docker pull hub.c.163.com/ubuntu:latest pull子命令支持的选项主要包括-a, --all-tags=true|false 是否获取从那个库中的所有镜像，默认为false，具体的选项可以通过 docker pull --help 命令查看。有了镜像后，我们就可以以这个镜像为基础启动一个容器来运行。以上面的 ubuntu:14.04 为例，如果我们打算启动里面的 bash 并且进行交互式操作的话，可以执行下面的命令。 1234567891011121314[root@localhost ~]# docker run -it --rm ubuntu:14.04 bashroot@21762fe64d8f:/# cat /etc/os-release NAME=&quot;Ubuntu&quot;VERSION=&quot;14.04.5 LTS, Trusty Tahr&quot;ID=ubuntuID_LIKE=debianPRETTY_NAME=&quot;Ubuntu 14.04.5 LTS&quot;VERSION_ID=&quot;14.04&quot;HOME_URL=&quot;http://www.ubuntu.com/&quot;SUPPORT_URL=&quot;http://help.ubuntu.com/&quot;BUG_REPORT_URL=&quot;http://bugs.launchpad.net/ubuntu/&quot;root@21762fe64d8f:/# exitexit[root@localhost ~]# docker run 就是运行容器的命令，我们这里简要的说明一下上面用到的参数。-it：这是两个参数，一个是 -i：交互式操作，一个是 -t 终端。我们这里打算进入 bash 执行一些命令并查看返回结果，因此我们需要交互式终端。--rm：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 docker rm 我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用 --rm 可以避免浪费空间。ubuntu:14.04：这是指用 ubuntu:14.04 镜像为基础来启动容器。bash：放在镜像名后的命令，这里我们希望有个交互式 Shell，因此用的是 bash。进入容器后，我们可以在 Shell 下操作，执行任何所需的命令。这里，我们执行了 cat /etc/os-release，这是 Linux 常用的查看当前系统版本的命令，从返回的结果可以看到容器内是 Ubuntu 14.04.5 LTS 系统。最后我们通过 exit 退出了这个容器。 查看镜像信息使用docker images命令可以查看本地已存在镜像1234[root@localhost ~]# docker images REPOSITORY TAG IMAGE ID CREATED SIZEdocker.io/ubuntu 14.04 ccc7a11d65b1 4 weeks ago 120.1 MBdocker.io/ubuntu latest ccc7a11d65b1 4 weeks ago 120.1 MB 在列出的信息中有5个字段，分别是镜像来自哪个仓库、标签、镜像ID、创建时间。 docker images -a列出所有镜像文件 docker images -q仅列出镜像ID docker images -f dangling=true列出没有别使用的镜像 使用docker tag命令给镜像添加新标签 1[root@localhost ~]# docker tag ubuntu:14.04 ubuntu:14 然后使用docker images查看镜像,多了一个拥有ubuntu:14标签的镜像12345[root@localhost ~]# docker images REPOSITORY TAG IMAGE ID CREATED SIZEdocker.io/ubuntu 14 ccc7a11d65b1 4 weeks ago 120.1 MBdocker.io/ubuntu 14.04 ccc7a11d65b1 4 weeks ago 120.1 MBdocker.io/ubuntu latest ccc7a11d65b1 4 weeks ago 120.1 MB 使用docker inspect命令查看镜像详细信息。 包括制作者、适应架构、各层的数字摘要等等信息。 使用docker history name:tag查看镜像历史比如查看ubuntu:latest镜像的创建过程12345678[root@yangjian06 wso2am]# docker history ubuntu:latestIMAGE CREATED CREATED BY SIZE COMMENTccc7a11d65b1 5 weeks ago /bin/sh -c #(nop) CMD [&quot;/bin/bash&quot;] 0 B &lt;missing&gt; 5 weeks ago /bin/sh -c mkdir -p /run/systemd &amp;&amp; echo &apos;doc 7 B &lt;missing&gt; 5 weeks ago /bin/sh -c sed -i &apos;s/^#\s*\(deb.*universe\)$/ 2.759 kB &lt;missing&gt; 5 weeks ago /bin/sh -c rm -rf /var/lib/apt/lists/* 0 B &lt;missing&gt; 5 weeks ago /bin/sh -c set -xe &amp;&amp; echo &apos;#!/bin/sh&apos; &gt; /u 745 B &lt;missing&gt; 5 weeks ago /bin/sh -c #(nop) ADD file:39d3593ea220e686d5 120.1 MB 过长的命令被截断了，可以使用--no-trunc选项输出完整命令 搜索镜像使用docker search命令可以搜索镜像库里中共享的镜像，默认搜索官方仓库的镜像。比如我们搜索nginx镜像 123456789[root@yangjian06 wso2am]# docker search -s 40 nginxINDEX NAME DESCRIPTION STARS OFFICIAL AUTOMATEDdocker.io docker.io/nginx Official build of Nginx. 6865 [OK] docker.io docker.io/jwilder/nginx-proxy Automated Nginx reverse proxy for docker c... 1124 [OK]docker.io docker.io/richarvey/nginx-php-fpm Container running Nginx + PHP-FPM capable ... 439 [OK]docker.io docker.io/jrcs/letsencrypt-nginx-proxy-companion LetsEncrypt container to use with nginx as... 223 [OK]docker.io docker.io/kong Open-source Microservice &amp; API Management ... 112 [OK] docker.io docker.io/webdevops/php-nginx Nginx with PHP-FPM 90 [OK]docker.io docker.io/kitematic/hello-world-nginx A light-weight nginx container that demons... 85 输出结果将按照星级评级进行排训，-s参数表示星级40以上的nginx镜像，支持的参数还有 --automated=true|false 仅显示自动创建的镜像，默认为否 --no-trunc=true|false 输出信息不截断提示，默认为否删除镜像命令docker rmi可以删除镜像使用标签删除镜像，例如我们删除ubuntu:14镜像 12[root@localhost ~]# docker rmi ubuntu:14Untagged: ubuntu:14 如果该镜像有多个标签的话删除的只是标签并不会删除镜像。如果只有一个标签的话docker rmi命令会彻底删除镜像。 使用id删除镜像使用命令docker rmi ID命令可以删除镜像 当有该镜像创建的容器存在时，镜像是无法删除的。如果要强行删除的话可以使用docker rmi -f ID 创建镜像创建镜像的方法主要有三种：基于已有镜像的容器创建，基于本地模板导入，基于dockerfile创建镜像 基于已有镜像的容器创建该方法主要是用docker commit命令创建镜像，主要参数为 -a，–auther=”” 作者信息 -m, –message=”” 提交信息 首先我们启动一个nginx镜像,然后进入容器，创建一个test文件，退出。 123456[root@localhost ~]# docker run -d -p 80:80 nginx00fb093d0ec2044f6a5d62fe2aa64c487e427456bd53cb6dc8b6462be4e25167[root@localhost ~]# docker exec -it 00fb093d0 bash root@00fb093d0ec2:/# touch testroot@00fb093d0ec2:/# exit[root@localhost ~]# 这时容器已发生了改变，使用docker commit命令创建一个新的镜像 12[root@localhost ~]# docker commit -a rgl -m &quot;add a new file&quot; 00fb093d0ec2 test:0.1sha256:bcaa64525c2bde4e1329f7b28bc2c98b2947f83a5cb0efff6e9d968a85618930 创建成功的话会返回新镜像的id。 保存和加载镜像如果要存出镜像到本地文件，可以使用docker save命令 1[root@localhost ~]# docker save -o nginx.tar nginx:latest 这样就可以通过复制该镜像文件分享给其他人如果要把镜像文件载入到本地镜像库，使用命令docker load。 12[root@localhost ~]# docker load --input nginx.tar Loaded image: nginx:latest 或者1234[root@localhost ~]# docker save nginx:latest &gt; nginx.tar Loaded image: nginx:latest[root@localhost ~]# docker load &lt; nginx.tar Loaded image: nginx:latest 上传镜像使用docker push命令上传镜像到仓库，默认上传到Docker官方仓库（需要登录）。例如我们自制的nginx：1.10.0镜像上传，首先我们要添加新的标签user/nginx:1.10.0 ,然后用docker push上传镜像，user改成你的用户名。 12345[root@localhost ~]# docker push user/nginx:1.10.0The push refers to a repository [docker.io/user/nginx]110566462efa: Mounted from library/nginx 305e2b6ef454: Mounted from library/nginx 1.10.0: digest: sha256:d8565c25b654da69bc9b837a0dee713c988f0276e90564aa8fd12ebf4c2ff11e size: 948]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker入门之安装]]></title>
    <url>%2Farticle%2Fdocker-deploy.html</url>
    <content type="text"><![CDATA[由于本人系统是centos,所以只演示在centos下的docke安装。其他系统请参考docker官方文档 Centos下安装docker系统要求：64为操作系统，内核版本至少为3.10docker目前支持Centos6.5及以上的版本 yum安装执行以下命令添加docker的yum源1yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 对于centos7，Centos-Extras源中已经内置了docker，可以直接通过yum安装1yum install -y docker 启动docker1systemctl start docker.service 设置docker开启自启动1systemclt enable docker.service]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker入门之简介]]></title>
    <url>%2Farticle%2Fdocker-summary.html</url>
    <content type="text"><![CDATA[什么是docker docker是一个开源的应用容器引擎; docker是一个开源的软件部署解决方案； docker也是轻量级的应用容器框架； docker可以打包、发布、运行任何的应用。 下面的图片比较了 docker 和传统虚拟化方式的不同之处。传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。 为什么要用docker作为一种新兴的虚拟化方式，docker 跟传统的虚拟化方式相比具有众多的优势。 更高效的利用系统资源由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，docker 对系统资源的利用率更高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。 更快速的启动时间传统的虚拟机技术启动应用服务往往需要数分钟，而 docker 容器应用，由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。 一致的运行环境开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环境不一致，导致有些 bug 并未在开发过程中被发现。而 docker 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 「这段代码在我机器上没问题啊」 这类问题。 持续交付和部署对开发和运维（DevOps）人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。使用 docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过 dockerfile 来进行镜像构建，并结合 持续集成(Continuous Integration) 系统进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合 持续部署(Continuous Delivery/Deployment) 系统进行自动部署。而且使用 dockerfile 使镜像构建透明化，不仅仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需条件，帮助更好的生产环境中部署该镜像。 更轻松的迁移由于 docker 确保了执行环境的一致性，使得应用的迁移更加容易。docker 可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。 更轻松的维护和扩展docker 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。此外，docker 团队同各个开源项目团队一起维护了一大批高质量的官方镜像，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本。 对比传统虚拟机总结 特性 容器 虚拟机 启动 秒级 分钟级 硬盘使用 一般为 MB 一般为 GB 性能 接近原生 弱于 系统支持量 单机支持上千个容器 一般几十个 百度百科]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo之博客搭建]]></title>
    <url>%2Farticle%2Fhexo.html</url>
    <content type="text"><![CDATA[什么是 Hexo？Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页，详情请看hexo官网。在使用之前电脑必须安装nodejs和git 安装hexo1234$ npm install -g hexo-cli$ hexo init blog$ cd blog$ npm install 创建新文章1$ hexo new "文章标题" 如果文章标题之间有空格要用引号引起来 运行1$ hexo server 打开浏览器，在地址栏输入 localhost:4000就会出现如下界面]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
