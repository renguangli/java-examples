<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[docker入门之Dockerfile]]></title>
    <url>%2Farticle%2Fdockerfile.html</url>
    <content type="text"><![CDATA[我们可以使用Dockerfile创建镜像，下面对Dockerfile指令进行简单介绍。 FROMFROM指定基础镜像，若镜像不存在Docker会从docker hub中 来查找该镜像。FROM命令必须是Dockerfile的首个命令。 1FROM centos:7.2.1511 MAINTAINER维护者信息,一般用来指定作者,紧跟FROM命令 1MAINTAINER Ren Guangli &lt;renguangli@bonc.com.cn&gt; ADDDockerfile中的COPY指令和ADD指令都可以将主机上的资源复制或加入到容器镜像中，都是在构建镜像的过程中完成的。ADD指令不仅能够将构建命令所在的主机本地的文件或目录，而且能够将远程URL所对应的文件或目录，作为资源复制到镜像文件系统。如果源文件是identity, gzip, bzip2，xz，tar.gz，tgz等类型的压缩文件，会添加tar -x命令，自动解压 对于从远程URL获取资源的情况，由于ADD指令不支持认证，如果从远程获取资源需要认证，则只能使用RUN wget或RUN curl替代。另外，如果源路径的资源发生变化，则该ADD指令将使Docker Cache失效，Dockerfile中后续的所有指令都不能使用缓存。因此尽量将ADD指令放在Dockerfile的后面。 123# exec格式用法ADD [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;]ADD [&quot;hello.sh&quot;,&quot;docker.sh&quot;,&quot;/mnt&quot;] 适合路径中带有空格的情况123# shell格式用法ADD &lt;src&gt;... &lt;dest&gt;ADD hello.sh docker.sh /mnt 注意事项 源路径可以有多个 源路径是相对于执行build的相对路径 源路径如果是本地路径，必须是build上下文中的路径 源路径如果是一个目录，则该目录下的所有内容都将被加入到容器，但是该目录本身不会 目标路径必须是绝对路径，或相对于WORKDIR的相对路径 目标路径如果不存在，则会创建相应的完整路径 路径中可以使用通配符 COPY和ADD指令类似，只是不能从远端获取资源和自动解压压缩文件 ENV配置环境变量 12ENV &lt;key&gt; &lt;value&gt;ENV &lt;key&gt;=&lt;value&gt; ... 第二种格式可以设置多个键值对，推荐在一条ENV指令中设置多个键值对，因为这样产生一个缓存层。 1ENV JAVA_HOME=/mnt/jdk1.7 PATH=$JAVA_HOME/bin:$PATH CLASSPATH=.:$JAVA_HOME/lib EXPOSE1EXPOSE &lt;port&gt; [&lt;port&gt;...] 指定于外界交互的端口 1EXPOSE 8080 443 在容器启动时用-p传递参数，例如docker run -d -p 8088:8080 -p 8089:443 tomcat:7.0.81将容器内的8080绑定到本机的8088端口,443绑定到本机的8089端口 USER1USER root 指定运行容器时的用户名或 UID，后续的RUN、CMD、ENTRYPOINT也会使用指定用户。 WORKDIR1WORKDIR /path/to/workdir 为后续的RUN、CMD、ENTRYPOINT指令配置工作目录。可以使用多个WORKDIR指令，后续命令如果参数是相对路径，则会基于之前命令指定的路径 1234WORKDIR /aWORKDIR bWORKDIR cRUN pwd 最终路径是/a/b/c。 WORKDIR指令可以在ENV设置变量之后调用环境变量: 12ENV DIRPATH /pathWORKDIR $DIRPATH/$DIRNAME 最终路径则为 /path/$DIRNAME。 参考连接http://www.docker.org.cn/dockerppt/114.htmlhttp://www.cnblogs.com/sorex/p/6481407.htmlhttp://blog.csdn.net/taiyangdao/article/details/73222601]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker入门之容器]]></title>
    <url>%2Farticle%2Fdocker-container.html</url>
    <content type="text"><![CDATA[容器是docker的另一个核心概念，简单来说容器就是镜像的一个运行示例。 查看容器使用docker ps命令查看运行着的容器 123[root@localhost ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES229929eb660f renguangli/nginx:1.0 &quot;nginx -g &apos;daemon off&quot; 17 hours ago Up 3 seconds 0.0.0.0:80-&gt;80/tcp nginx 使用docker ps -a命令查看所有的容器 1234[root@localhost ~]# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES229929eb660f renguangli/nginx:1.0 &quot;nginx -g &apos;daemon off&quot; 17 hours ago Up 3 seconds 0.0.0.0:80-&gt;80/tcp nginx3ceb621f4aa9 jenkins &quot;/bin/tini -- /usr/lo&quot; About an hour ago Exited (137) 48 seconds ago elated_davinci 使用docker ps -q命令查看运行着的容器Id 使用docker create image:tag name命令创建一个容器并给容器一个name，例如 12[root@localhost ~]# docker create nginx:latest nginxfd47cedfcce5cd2879ef65b342b1cd4130cbcc081cec532ff7af1744ad589116 如果不加name的话随机分配一个名字 启动容器使用docker start 容器名称或容器ID来启动一个容器，例如 123[root@localhost ~]# docker ps -a229929eb660f renguangli/nginx:1.0 &quot;nginx -g &apos;daemon off&quot; 17 hours ago Exited (0) 8 seconds ago nginx[root@localhost ~]# docker start nginx 或者 docker start 229929eb660f 新建并启动容器创建容器后可以用docker start命令启动容器，也可以用docker run命令直接新建并启动容器，docker run相当于先执行docker create命令在执行docker start名利。例如，输出一个”hello docker” 12[root@localhost ~]# docker run ubuntu echo &quot;hello docker&quot;hello docker 这跟在本次执行echo &quot;hello docker&quot;几乎没有任何区别，但是在执行docker run命令时经历了复杂的操作： 检查本地是否存在指定的镜像，，不存在就从共有仓库下载 利用镜像创建并启动一个容器 分配一个文件系统给容器，并在只读的镜像层外面挂在一个可读写层 从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中 从王桥的地址池中配置一个IP地址给容器 执行用户指定的应用程序 执行完毕后容器自动终止 docker run -d命令会让容器在后台运行docker logs名利可以查看容器日志docker logs -f命令可以像tail -f命令一样查看容器日志 终止容器使用docker stop 容器名或容器ID命令停止一个容器 1234[root@localhost html]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES16555d4ebdf0 nginx:1.10.0 &quot;nginx -g &apos;daemon off&quot; 47 minutes ago Up 8 seconds 0.0.0.0:80-&gt;80/tcp jolly_goodall[root@localhost html]# docker stop 16555d4ebdf0 或者 docker stop jolly_goodall docker stop命令首先想容器发送SIGKILL的信号，等待一段时间后（默认10秒）在发送SIGKILL信号来终止容器docker kill 命令会直接发送SIGKILL信号来终止容器 终止的容器可以使用docer start来启动一个容器 运行着的容器可以使用docker restart来重启容器]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker入门之镜像]]></title>
    <url>%2Farticle%2Fdocker-image.html</url>
    <content type="text"><![CDATA[docker镜像类似于虚拟机镜像，可以将它理解为一个只读的模板。例如，一个镜像可以包含一个基本的操作系统，里面安装了tomcat(或者其它软件)，我们把它称为tomcat镜像。镜像是创建docker容器的基础。通过版本管理和增量的文件系统，docker提供了十分简单的机制来创建和更新的现有的镜像，也可以从镜像仓库里pull镜像，就像git pull代码一样。 获取镜像镜像是容器运行的前提条件，官方DockerHub 镜像仓库提供了很多个镜像提供大家开放下载。我们可以直接使用docker pull命令直接从Docker Hub镜像源下载镜像命令格式：docker pull name:tagname为镜像名称，tag为镜像的标签(通常用来表示版本信息)\获取一个Ubuntu 14.04系统镜像可以使用docker pull ubuntu:14.041[root@localhost ~]# docker pull ubuntu:14.04 如果不指定tag，则默认会选择latest标签，下载仓库中最新版本的镜像。严格地讲仓库名称还要添加镜像地址(即registry，注册服务器）为前缀，我们使用的是官方Docker Hub，所以前缀可以省略,完整命令为docker pull docker.io/library/ubuntu:14.04如果下载非官方的镜像，仓库名称前要指定完整的仓库地址。例如我们从网易的镜像源下载ubuntu 14.04 正确命令为 1docker pull hub.c.163.com/ubuntu:latest pull子命令支持的选项主要包括-a, --all-tags=true|false 是否获取从那个库中的所有镜像，默认为false，具体的选项可以通过 docker pull --help 命令查看。有了镜像后，我们就可以以这个镜像为基础启动一个容器来运行。以上面的 ubuntu:14.04 为例，如果我们打算启动里面的 bash 并且进行交互式操作的话，可以执行下面的命令。 1234567891011121314[root@localhost ~]# docker run -it --rm ubuntu:14.04 bashroot@21762fe64d8f:/# cat /etc/os-release NAME=&quot;Ubuntu&quot;VERSION=&quot;14.04.5 LTS, Trusty Tahr&quot;ID=ubuntuID_LIKE=debianPRETTY_NAME=&quot;Ubuntu 14.04.5 LTS&quot;VERSION_ID=&quot;14.04&quot;HOME_URL=&quot;http://www.ubuntu.com/&quot;SUPPORT_URL=&quot;http://help.ubuntu.com/&quot;BUG_REPORT_URL=&quot;http://bugs.launchpad.net/ubuntu/&quot;root@21762fe64d8f:/# exitexit[root@localhost ~]# docker run 就是运行容器的命令，我们这里简要的说明一下上面用到的参数。-it：这是两个参数，一个是 -i：交互式操作，一个是 -t 终端。我们这里打算进入 bash 执行一些命令并查看返回结果，因此我们需要交互式终端。--rm：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 docker rm 我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用 --rm 可以避免浪费空间。ubuntu:14.04：这是指用 ubuntu:14.04 镜像为基础来启动容器。bash：放在镜像名后的命令，这里我们希望有个交互式 Shell，因此用的是 bash。进入容器后，我们可以在 Shell 下操作，执行任何所需的命令。这里，我们执行了 cat /etc/os-release，这是 Linux 常用的查看当前系统版本的命令，从返回的结果可以看到容器内是 Ubuntu 14.04.5 LTS 系统。最后我们通过 exit 退出了这个容器。 查看镜像信息使用docker images命令可以查看本地已存在镜像1234[root@localhost ~]# docker images REPOSITORY TAG IMAGE ID CREATED SIZEdocker.io/ubuntu 14.04 ccc7a11d65b1 4 weeks ago 120.1 MBdocker.io/ubuntu latest ccc7a11d65b1 4 weeks ago 120.1 MB 在列出的信息中有5个字段，分别是镜像来自哪个仓库、标签、镜像ID、创建时间。 docker images -a列出所有镜像文件 docker images -q仅列出镜像ID docker images -f dangling=true列出没有别使用的镜像 使用docker tag命令给镜像添加新标签 1[root@localhost ~]# docker tag ubuntu:14.04 ubuntu:14 然后使用docker images查看镜像,多了一个拥有ubuntu:14标签的镜像12345[root@localhost ~]# docker images REPOSITORY TAG IMAGE ID CREATED SIZEdocker.io/ubuntu 14 ccc7a11d65b1 4 weeks ago 120.1 MBdocker.io/ubuntu 14.04 ccc7a11d65b1 4 weeks ago 120.1 MBdocker.io/ubuntu latest ccc7a11d65b1 4 weeks ago 120.1 MB 使用docker inspect命令查看镜像详细信息。 包括制作者、适应架构、各层的数字摘要等等信息。 使用docker history name:tag查看镜像历史比如查看ubuntu:latest镜像的创建过程12345678[root@yangjian06 wso2am]# docker history ubuntu:latestIMAGE CREATED CREATED BY SIZE COMMENTccc7a11d65b1 5 weeks ago /bin/sh -c #(nop) CMD [&quot;/bin/bash&quot;] 0 B &lt;missing&gt; 5 weeks ago /bin/sh -c mkdir -p /run/systemd &amp;&amp; echo &apos;doc 7 B &lt;missing&gt; 5 weeks ago /bin/sh -c sed -i &apos;s/^#\s*\(deb.*universe\)$/ 2.759 kB &lt;missing&gt; 5 weeks ago /bin/sh -c rm -rf /var/lib/apt/lists/* 0 B &lt;missing&gt; 5 weeks ago /bin/sh -c set -xe &amp;&amp; echo &apos;#!/bin/sh&apos; &gt; /u 745 B &lt;missing&gt; 5 weeks ago /bin/sh -c #(nop) ADD file:39d3593ea220e686d5 120.1 MB 过长的命令被截断了，可以使用--no-trunc选项输出完整命令 搜索镜像使用docker search命令可以搜索镜像库里中共享的镜像，默认搜索官方仓库的镜像。比如我们搜索nginx镜像 123456789[root@yangjian06 wso2am]# docker search -s 40 nginxINDEX NAME DESCRIPTION STARS OFFICIAL AUTOMATEDdocker.io docker.io/nginx Official build of Nginx. 6865 [OK] docker.io docker.io/jwilder/nginx-proxy Automated Nginx reverse proxy for docker c... 1124 [OK]docker.io docker.io/richarvey/nginx-php-fpm Container running Nginx + PHP-FPM capable ... 439 [OK]docker.io docker.io/jrcs/letsencrypt-nginx-proxy-companion LetsEncrypt container to use with nginx as... 223 [OK]docker.io docker.io/kong Open-source Microservice &amp; API Management ... 112 [OK] docker.io docker.io/webdevops/php-nginx Nginx with PHP-FPM 90 [OK]docker.io docker.io/kitematic/hello-world-nginx A light-weight nginx container that demons... 85 输出结果将按照星级评级进行排训，-s参数表示星级40以上的nginx镜像，支持的参数还有 --automated=true|false 仅显示自动创建的镜像，默认为否 --no-trunc=true|false 输出信息不截断提示，默认为否删除镜像命令docker rmi可以删除镜像使用标签删除镜像，例如我们删除ubuntu:14镜像 12[root@localhost ~]# docker rmi ubuntu:14Untagged: ubuntu:14 如果该镜像有多个标签的话删除的只是标签并不会删除镜像。如果只有一个标签的话docker rmi命令会彻底删除镜像。 使用id删除镜像使用命令docker rmi ID命令可以删除镜像 当有该镜像创建的容器存在时，镜像是无法删除的。如果要强行删除的话可以使用docker rmi -f ID 创建镜像创建镜像的方法主要有三种：基于已有镜像的容器创建，基于本地模板导入，基于dockerfile创建镜像 基于已有镜像的容器创建该方法主要是用docker commit命令创建镜像，主要参数为 -a，–auther=”” 作者信息 -m, –message=”” 提交信息 首先我们启动一个nginx镜像,然后进入容器，创建一个test文件，退出。 123456[root@localhost ~]# docker run -d -p 80:80 nginx00fb093d0ec2044f6a5d62fe2aa64c487e427456bd53cb6dc8b6462be4e25167[root@localhost ~]# docker exec -it 00fb093d0 bash root@00fb093d0ec2:/# touch testroot@00fb093d0ec2:/# exit[root@localhost ~]# 这时容器已发生了改变，使用docker commit命令创建一个新的镜像 12[root@localhost ~]# docker commit -a rgl -m &quot;add a new file&quot; 00fb093d0ec2 test:0.1sha256:bcaa64525c2bde4e1329f7b28bc2c98b2947f83a5cb0efff6e9d968a85618930 创建成功的话会返回新镜像的id。 保存和加载镜像如果要存出镜像到本地文件，可以使用docker save命令 1[root@localhost ~]# docker save -o nginx.tar nginx:latest 这样就可以通过复制该镜像文件分享给其他人如果要把镜像文件载入到本地镜像库，使用命令docker load。 12[root@localhost ~]# docker load --input nginx.tar Loaded image: nginx:latest 或者1234[root@localhost ~]# docker save nginx:latest &gt; nginx.tar Loaded image: nginx:latest[root@localhost ~]# docker load &lt; nginx.tar Loaded image: nginx:latest 上传镜像使用docker push命令上传镜像到仓库，默认上传到Docker官方仓库（需要登录）。例如我们自制的nginx：1.10.0镜像上传，首先我们要添加新的标签user/nginx:1.10.0 ,然后用docker push上传镜像，user改成你的用户名。 12345[root@localhost ~]# docker push user/nginx:1.10.0The push refers to a repository [docker.io/user/nginx]110566462efa: Mounted from library/nginx 305e2b6ef454: Mounted from library/nginx 1.10.0: digest: sha256:d8565c25b654da69bc9b837a0dee713c988f0276e90564aa8fd12ebf4c2ff11e size: 948]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker入门之安装]]></title>
    <url>%2Farticle%2Fdocker-deploy.html</url>
    <content type="text"><![CDATA[由于本人系统是centos,所以只演示在centos下的docke安装。其他系统请参考docker官方文档 Centos下安装docker系统要求：64为操作系统，内核版本至少为3.10docker目前支持Centos6.5及以上的版本 yum安装执行以下命令添加docker的yum源1yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 对于centos7，Centos-Extras源中已经内置了docker，可以直接通过yum安装1yum install -y docker 启动docker1systemctl start docker.service 设置docker开启自启动1systemclt enable docker.service]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker入门之简介]]></title>
    <url>%2Farticle%2Fdocker-summary.html</url>
    <content type="text"><![CDATA[什么是docker docker是一个开源的应用容器引擎; docker是一个开源的软件部署解决方案； docker也是轻量级的应用容器框架； docker可以打包、发布、运行任何的应用。 下面的图片比较了 docker 和传统虚拟化方式的不同之处。传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。 为什么要用docker作为一种新兴的虚拟化方式，docker 跟传统的虚拟化方式相比具有众多的优势。 更高效的利用系统资源由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，docker 对系统资源的利用率更高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。 更快速的启动时间传统的虚拟机技术启动应用服务往往需要数分钟，而 docker 容器应用，由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。 一致的运行环境开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环境不一致，导致有些 bug 并未在开发过程中被发现。而 docker 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 「这段代码在我机器上没问题啊」 这类问题。 持续交付和部署对开发和运维（DevOps）人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。使用 docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过 dockerfile 来进行镜像构建，并结合 持续集成(Continuous Integration) 系统进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合 持续部署(Continuous Delivery/Deployment) 系统进行自动部署。而且使用 dockerfile 使镜像构建透明化，不仅仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需条件，帮助更好的生产环境中部署该镜像。 更轻松的迁移由于 docker 确保了执行环境的一致性，使得应用的迁移更加容易。docker 可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。 更轻松的维护和扩展docker 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。此外，docker 团队同各个开源项目团队一起维护了一大批高质量的官方镜像，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本。 对比传统虚拟机总结 特性 容器 虚拟机 启动 秒级 分钟级 硬盘使用 一般为 MB 一般为 GB 性能 接近原生 弱于 系统支持量 单机支持上千个容器 一般几十个 百度百科]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo之博客搭建]]></title>
    <url>%2Farticle%2Fhexo.html</url>
    <content type="text"><![CDATA[什么是 Hexo？Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页，详情请看hexo官网。在使用之前电脑必须安装nodejs和git 安装hexo1234$ npm install -g hexo-cli$ hexo init blog$ cd blog$ npm install 创建新文章1$ hexo new "文章标题" 如果文章标题之间有空格要用引号引起来 运行1$ hexo server 打开浏览器，在地址栏输入 localhost:4000就会出现如下界面]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
