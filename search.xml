<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[DDOS攻击的防范教程]]></title>
    <url>%2Farticle%2Fddos.html</url>
    <content type="text"><![CDATA[转载自 阮一峰的网络日志 一个多月前，阮一峰老师的个人网站遭受 DDOS 攻击，下线了50多个小时。这篇文章就来谈谈，如何应对这种攻击。 需要说明的是，我对 DDOS 并不精通，从没想过自己会成为攻击目标。攻击发生以后，很多素昧平生的朋友提供了各种帮助和建议，让我学到了很多东西。这里记录的就是对我最有帮助的一些解决方案。 一、DDOS 是什么？首先，我来解释一下，DDOS 是什么。 举例来说，我开了一家餐厅，正常情况下，最多可以容纳30个人同时进餐。你直接走进餐厅，找一张桌子坐下点餐，马上就可以吃到东西。 很不幸，我得罪了一个流氓。他派出300个人同时涌进餐厅。这些人看上去跟正常的顾客一样，每个都说”赶快上餐”。但是，餐厅的容量只有30个人，根本不可能同时满足这么多的点餐需求，加上他们把门口都堵死了，里三层外三层，正常用餐的客人根本进不来，实际上就把餐厅瘫痪了。 这就是 DDOS 攻击，它在短时间内发起大量请求，耗尽服务器的资源，无法响应正常的访问，造成网站实质下线 DDOS 里面的 DOS 是 denial of service（停止服务）的缩写，表示这种攻击的目的，就是使得服务中断。最前面的那个 D 是 distributed （分布式），表示攻击不是来自一个地方，而是来自四面八方，因此更难防。你关了前门，他从后门进来；你关了后门，他从窗口跳起来。 二、DDOS 的种类DDOS 不是一种攻击，而是一大类攻击的总称。它有几十种类型，新的攻击方法还在不断发明出来。网站运行的各个环节，都可以是攻击目标。只要把一个环节攻破，使得整个流程跑不起来，就达到了瘫痪服务的目的。 其中，比较常见的一种攻击是 cc 攻击。它就是简单粗暴地送来大量正常的请求，超出服务器的最大承受量，导致宕机。我遭遇的就是 cc 攻击，最多的时候全世界大概20多个 IP 地址轮流发出请求，每个地址的请求量在每秒200次~300次。我看访问日志的时候，就觉得那些请求像洪水一样涌来，一眨眼就是一大堆，几分钟的时间，日志文件的体积就大了100MB。说实话，这只能算小攻击，但是我的个人网站没有任何防护，服务器还是跟其他人共享的，这种流量一来立刻就下线了。 本文以下的内容都是针对 cc 攻击。 三、备份网站防范 DDOS 的第一步，就是你要有一个备份网站，或者最低限度有一个临时主页。生产服务器万一下线了，可以立刻切换到备份网站，不至于毫无办法。 备份网站不一定是全功能的，如果能做到全静态浏览，就能满足需求。最低限度应该可以显示公告，告诉用户，网站出了问题，正在全力抢修。]]></content>
      <tags>
        <tag>ddos</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础-序列化与反序列化]]></title>
    <url>%2Farticle%2Fjava-serializable.html</url>
    <content type="text"><![CDATA[什么是序列化、反序列化？序列化是将对象转换为可传输格式的过程。 是一种数据的持久化手段。一般是以字节码或XML格式传输。而字节码或XML编码格式可以还原为完全相等的对象。这个相反的过程称为反序列化。 有哪些应用场景。一般广泛应用于网络传输，RMI和RPC等场景中。 Java中如何实现序列化和反序列化。被序列化的类要实现Serializable或者Externalizable接口当试图对一个对象进行序列化的时候，如果遇到不支持 Serializable 接口的对象。在此情况下，将抛出 NotSerializableException。 通过ObjectOutputStream和ObjectInputStream对对象进行序列化及反序列化 序列化并不保存静态变量。要想将父类对象也序列化，就需要让父类也实现Serializable 接口。Transient关键字的作用是控制变量的序列化，在变量声明前加上该关键字，可以阻止该变量被序列化到文件中，在被反序列化后，transient 变量的值被设为初始值，如 int 型的是 0，对象型的是 null。 安全服务器端给客户端发送序列化对象数据，对象中有一些数据是敏感的，比如密码字符串等，希望对该密码字段在序列化时，进行加密，而客户端如果拥有解密的密钥，只有在客户端进行反序列化时，才可以对密码进行读取，这样可以一定程度保证序列化对象的数据安全。 扩展]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[elasticsearch基础概念]]></title>
    <url>%2Farticle%2Felasticsearch-base-concepts.html</url>
    <content type="text"><![CDATA[Elasticsearch是一个近乎实时的搜索平台 集群群集是一个或多个节点（服务器）的集合，它们一起保存整个数据，并提供跨所有节点的联合索引和搜索功能。集群由默认名称为“elasticsearch”的唯一名称标识。此名称很重要，因为如果节点设置为通过名称加入群集，则节点只能成为群集的一部分。 确保不要在不同的环境中重复使用相同的群集名称，否则可能会导致节点加入错误的群集。例如，您可以使用logging-dev，logging-stage和logging-prod开发，分段和生产集群。 请注意，有一个只有一个节点的集群是完全正确的。此外，您还可能拥有多个独立的群集，每个群集都有自己的唯一群集名称。 节点节点是属于集群一部分的单个服务器，存储数据并参与集群的索引和搜索功能。就像一个集群一样，一个节点由一个名称来标识，默认情况下该名称是在启动时分配给节点的随机通用唯一标识符（UUID）。如果您不需要默认值，您可以定义任何您想要的节点名称。此名称对于管理目的非常重要，您可以在其中识别网络中哪些服务器与Elasticsearch集群中的哪些节点相对应。 可以将节点配置为按集群名称加入特定集群。默认情况下，每个节点都设置为加入名为elasticsearch的集群，这意味着如果启动网络中的多个节点并假设他们可以发现其他节点，它们将自动形成并加入名为elasticsearch的单个集群。 在单个群集中，您可以拥有任意数量的节点。此外，如果您的网络上当前没有其他Elasticsearch节点正在运行，则默认情况下，启动单个节点将形成名为elasticsearch的新单节点集群。 索引(index)索引是一些具有相似特征的文档集合。例如，您可以拥有客户数据的索引，产品目录的另一个索引以及订单数据的另一个索引。索引由名称标识（必须全部小写），此名称用于在对其中的文档执行索引，搜索，更新和删除操作时引用索引。 在单个群集中，您可以根据需要定义任意数量的索引。 类型(type)一种类型，曾经是索引的逻辑类别/分区，允许您在同一索引中存储不同类型的文档，例如，一种类型用于用户，另一种类型用于博客帖子。不再可能在索引中创建多个类型，并且将在更高版本中删除类型的整个概念。 Shards &amp; Replicas索引可能潜在地存储大量数据，这些数据可能会超出单个节点的硬件限制。例如，占用1TB磁盘空间的十亿份文档的单个索引可能不适合单个节点的磁盘，或者可能太慢而无法单独向单个节点提供搜索请求。 为了解决这个问题，Elasticsearch提供了将索引细分为多个碎片的能力。当您创建索引时，您可以简单地定义所需的碎片数量。每个分片本身都是一个功能齐全且独立的“索引”，可以托管在集群中的任何节点上。 分片很重要，主要有两个原因： 它允许您水平分割/缩放内容量它允许您跨越分片（可能在多个节点上）分发和并行化操作，从而提高性能/吞吐量分片如何分布的机制以及其文档如何聚合回搜索请求完全由Elasticsearch管理，并且作为用户对您透明。 在可以随时发生故障的网络/云环境中，非常有用，强烈建议使用故障转移机制，以防分片/节点以某种方式脱机或因任何原因消失。为此，Elasticsearch允许您将索引碎片的一个或多个副本制作为简称为副本碎片或副本。 复制很重要，主要有两个原因： 它在碎片/节点失败的情况下提供高可用性。因此，请务必注意，副本分片永远不会在与从中复制的原始/主分片相同的节点上分配。它允许您扩展搜索量/吞吐量，因为搜索可以在所有副本上并行执行。总而言之，每个索引可以拆分为多个分片。索引也可以被复制为零（意味着没有副本）或更多次。一旦复制，每个索引将具有主分片（从中复制的原始分片）和副本分片（主分片的副本）。可以在创建索引时为每个索引定义分片和副本的数量。在创建索引之后，您可以随时更改动态副本的数量，但您无法在事后更改碎片的数量。 默认情况下，Elasticsearch中的每个索引都分配了5个主分片和1个副本，这意味着如果群集中至少有两个节点，则索引将包含5个主分片和另外5个副本分片（1个完整副本），总共每个索引10个碎片。 每个Elasticsearch分片都是一个Lucene索引。您可以在单个Lucene索引中拥有最大数量的文档。自LUCENE-5843起，限制为2,147,483,519（= Integer.MAX_VALUE - 128）个文件。您可以使用_cat / shards API监视分片大小。]]></content>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java8之Object源码阅读]]></title>
    <url>%2Farticle%2Fjava8-Object.html</url>
    <content type="text"><![CDATA[Object作为所有类的父类，还是有必要研究一下的。Object类一共有以下几个方法下面我们一个一个来看。 clone()clone方法是用来拷贝对象的，他是本地方法，由c++实现。clone方法只是浅拷贝，如果对象中包含了另一个复杂对象，clone出来的对象存在被修改的风险。 大家来看下面一个例子 123456public class Node &#123; String name; public Node(String name) &#123; this.name = name; &#125;&#125; 定义一个User类 1234567891011121314151617public class User implements Cloneable&#123; Node node; int age; public User() &#123; &#125; public User(int age, Node node) &#123; this.age = age; this.node = node; &#125; @Override public String toString() &#123; return "User&#123;age=" + age + ",node=" + node.name + "&#125;"; &#125; @Override protected User clone() throws CloneNotSupportedException &#123; return (User) super.clone(); &#125;&#125; 123456public static void main(String[] args) throws CloneNotSupportedException &#123; User user1 = new User(new Node("张三"), 18); User user2 = user1.clone(); user2.node.name = "李四"; System.out.println(user1);&#125; 打印结果 User{age=18,node=李四} 看最后一行输出，当我们改变user2的node属性时，user1的node属性也改变了，说明clone方法只是拷贝了node属性的引用，实际上user1、user2的node属性指向的是堆内存中的同一个对象。]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[什么是JDK、JRE、JVM？]]></title>
    <url>%2Farticle%2Fjdk-jre-jvm.html</url>
    <content type="text"><![CDATA[下面贴一张图来看看他们之间的关系 再看一张java官方更详细的结构图 什么是jdk、jre、jvm？JDK(Java Development Kit) 是Java语言的软件开发工具包，包含了一些开发工具JAVA运行时环境JRE。jdk包含的开发工具有： javac – 编译器，将源程序转成字节码 jar – 打包工具，将相关的类文件打包成一个文件 javadoc – 文档生成器，从源码注释中提取文档 jdb – debugger，查错工具 java – 运行编译后的java程序（.class后缀的） appletviewer：小程序浏览器，一种执行HTML文件上的Java小程序的Java浏览器。 Javah：产生可以调用Java过程的C过程，或建立能被Java程序调用的C过程的头文件。 Javap：Java反汇编器，显示编译类文件中的可访问功能和数据，同时显示字节代码含义。 console: Java进行系统调试和监控的工具…… jRE（Java Runtime Environment，Java运行环境），包含JVM标准实现及Java核心类库。JRE是Java运行环境，如果你只想运行java程序，只需要安装JRE即可。 JVM是Java Virtual Machine（Java虚拟机）的缩写，JVM是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。 java的一次编写、出处运行就是基于JVM实现的。 JDK、JRE、JVM的用途JDK是用来开发java程序所必须的。 JRE是java程序运行所必须的。 JVM是用来加载class文件也是一次编写、处处运行的实现。]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每天学点儿linux--centos配置nginx-yum源]]></title>
    <url>%2Farticle%2Fnginx-yum.html</url>
    <content type="text"><![CDATA[创建/etc/yum.repos.d/nginx.repo文件，并添加一下内容 12345[nginx]name=nginx repobaseurl=http://nginx.org/packages/OS/OSRELEASE/$basearch/gpgcheck=0enabled=1 将OS替换为“rhel” 或者 “centos”， “OSRELEASE”替换为7或6,取决与你的centos系统版本，6代表6.X版本，7代表7.X版本。替换完之后保存文件，然后就可以使用yum安装nignx了 1yum install nginx 参考资料http://nginx.org/en/linux_packages.html]]></content>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每天学点儿linux--centos7开放端口号]]></title>
    <url>%2Farticle%2Fcentos-open-port.html</url>
    <content type="text"><![CDATA[开放80端口1firewall-cmd --zone=public --add-port=80/tcp --permanent 命令含义： –zone #作用域 –add-port=80/tcp #添加端口，格式为：端口/通讯协议 –permanent #永久生效，没有此参数重启后失效 关闭80端口 1firewall-cmd --zone=public --remove-port=80/tcp --permanent 查看防火墙状态 1systemctl status firewalld.service 启动|关闭|重新启动 防火墙 1systemctl [start|stop|restart] firewalld.service]]></content>
      <tags>
        <tag>每天学点儿linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字节码指令集]]></title>
    <url>%2Farticle%2Fclass.html</url>
    <content type="text"><![CDATA[以下为字节码指令集，方便查看nop 什么都不做aconst_null 将null推送至栈顶iconst_m1 将int型-1推送至栈顶iconst_0 将int型0推送至栈顶iconst_1 将int型1推送至栈顶iconst_2 将int型2推送至栈顶iconst_3 将int型3推送至栈顶iconst_4 将int型4推送至栈顶iconst_5 将int型5推送至栈顶lconst_0 将long型0推送至栈顶lconst_1 将long型1推送至栈顶fconst_0 将float型0推送至栈顶fconst_1 将float型1推送至栈顶fconst_2 将float型2推送至栈顶dconst_0 将do le型0推送至栈顶dconst_1 将do le型1推送至栈顶bipush 将单字节的常量值(-128~127)推送至栈顶sipush 将一个短整型常量值(-32768~32767)推送至栈顶ldc 将int, float或String型常量值从常量池中推送至栈顶ldc_w 将int, float或String型常量值从常量池中推送至栈顶（宽索引）ldc2_w 将long或do le型常量值从常量池中推送至栈顶（宽索引）iload 将指定的int型本地变量lload 将指定的long型本地变量fload 将指定的float型本地变量dload 将指定的do le型本地变量aload 将指定的引用类型本地变量iload_0 将第一个int型本地变量iload_1 将第二个int型本地变量iload_2 将第三个int型本地变量iload_3 将第四个int型本地变量lload_0 将第一个long型本地变量lload_1 将第二个long型本地变量lload_2 将第三个long型本地变量lload_3 将第四个long型本地变量fload_0 将第一个float型本地变量fload_1 将第二个float型本地变量fload_2 将第三个float型本地变量fload_3 将第四个float型本地变量dload_0 将第一个do le型本地变量dload_1 将第二个do le型本地变量dload_2 将第三个do le型本地变量dload_3 将第四个do le型本地变量aload_0 将第一个引用类型本地变量aload_1 将第二个引用类型本地变量aload_2 将第三个引用类型本地变量aload_3 将第四个引用类型本地变量iaload 将int型数组指定索引的值推送至栈顶laload 将long型数组指定索引的值推送至栈顶faload 将float型数组指定索引的值推送至栈顶daload 将do le型数组指定索引的值推送至栈顶aaload 将引用型数组指定索引的值推送至栈顶baload 将boolean或byte型数组指定索引的值推送至栈顶caload 将char型数组指定索引的值推送至栈顶saload 将short型数组指定索引的值推送至栈顶istore 将栈顶int型数值存入指定本地变量lstore 将栈顶long型数值存入指定本地变量fstore 将栈顶float型数值存入指定本地变量dstore 将栈顶do le型数值存入指定本地变量astore 将栈顶引用型数值存入指定本地变量istore_0 将栈顶int型数值存入第一个本地变量istore_1 将栈顶int型数值存入第二个本地变量istore_2 将栈顶int型数值存入第三个本地变量istore_3 将栈顶int型数值存入第四个本地变量lstore_0 将栈顶long型数值存入第一个本地变量lstore_1 将栈顶long型数值存入第二个本地变量lstore_2 将栈顶long型数值存入第三个本地变量lstore_3 将栈顶long型数值存入第四个本地变量fstore_0 将栈顶float型数值存入第一个本地变量fstore_1 将栈顶float型数值存入第二个本地变量fstore_2 将栈顶float型数值存入第三个本地变量fstore_3 将栈顶float型数值存入第四个本地变量dstore_0 将栈顶do le型数值存入第一个本地变量dstore_1 将栈顶do le型数值存入第二个本地变量dstore_2 将栈顶do le型数值存入第三个本地变量dstore_3 将栈顶do le型数值存入第四个本地变量astore_0 将栈顶引用型数值存入第一个本地变量astore_1 将栈顶引用型数值存入第二个本地变量astore_2 将栈顶引用型数值存入第三个本地变量astore_3 将栈顶引用型数值存入第四个本地变量iastore 将栈顶int型数值存入指定数组的指定索引位置lastore 将栈顶long型数值存入指定数组的指定索引位置fastore 将栈顶float型数值存入指定数组的指定索引位置dastore 将栈顶do le型数值存入指定数组的指定索引位置aastore 将栈顶引用型数值存入指定数组的指定索引位置bastore 将栈顶boolean或byte型数值存入指定数组的指定索引位置castore 将栈顶char型数值存入指定数组的指定索引位置sastore 将栈顶short型数值存入指定数组的指定索引位置pop 将栈顶数值弹出 (数值不能是long或do le类型的)pop2 将栈顶的一个（long或do le类型的)或两个数值弹出（其它）dup 复制栈顶数值并将复制值压入栈顶dup_x1 复制栈顶数值并将两个复制值压入栈顶dup_x2 复制栈顶数值并将三个（或两个）复制值压入栈顶dup2 复制栈顶一个（long或do le类型的)或两个（其它）数值并将复制值压入栈顶dup2_x1 dup_x1 指令的双倍版本dup2_x2 dup_x2 指令的双倍版本swap 将栈最顶端的两个数值互换(数值不能是long或do le类型的)iadd 将栈顶两int型数值相加并将结果压入栈顶ladd 将栈顶两long型数值相加并将结果压入栈顶fadd 将栈顶两float型数值相加并将结果压入栈顶dadd 将栈顶两do le型数值相加并将结果压入栈顶is 将栈顶两int型数值相减并将结果压入栈顶ls 将栈顶两long型数值相减并将结果压入栈顶fs 将栈顶两float型数值相减并将结果压入栈顶ds 将栈顶两do le型数值相减并将结果压入栈顶imul 将栈顶两int型数值相乘并将结果压入栈顶lmul 将栈顶两long型数值相乘并将结果压入栈顶fmul 将栈顶两float型数值相乘并将结果压入栈顶dmul 将栈顶两do le型数值相乘并将结果压入栈顶idiv 将栈顶两int型数值相除并将结果压入栈顶ldiv 将栈顶两long型数值相除并将结果压入栈顶fdiv 将栈顶两float型数值相除并将结果压入栈顶ddiv 将栈顶两do le型数值相除并将结果压入栈顶irem 将栈顶两int型数值作取模运算并将结果压入栈顶lrem 将栈顶两long型数值作取模运算并将结果压入栈顶frem 将栈顶两float型数值作取模运算并将结果压入栈顶drem 将栈顶两do le型数值作取模运算并将结果压入栈顶ineg 将栈顶int型数值取负并将结果压入栈顶lneg 将栈顶long型数值取负并将结果压入栈顶fneg 将栈顶float型数值取负并将结果压入栈顶dneg 将栈顶do le型数值取负并将结果压入栈顶ishl 将int型数值左移位指定位数并将结果压入栈顶lshl 将long型数值左移位指定位数并将结果压入栈顶ishr 将int型数值右（符号）移位指定位数并将结果压入栈顶lshr 将long型数值右（符号）移位指定位数并将结果压入栈顶iushr 将int型数值右（无符号）移位指定位数并将结果压入栈顶lushr 将long型数值右（无符号）移位指定位数并将结果压入栈顶iand 将栈顶两int型数值作“按位与”并将结果压入栈顶land 将栈顶两long型数值作“按位与”并将结果压入栈顶ior 将栈顶两int型数值作“按位或”并将结果压入栈顶lor 将栈顶两long型数值作“按位或”并将结果压入栈顶ixor 将栈顶两int型数值作“按位异或”并将结果压入栈顶lxor 将栈顶两long型数值作“按位异或”并将结果压入栈顶iinc 将指定int型变量增加指定值（i++, i–, i+=2）i2l 将栈顶int型数值强制转换成long型数值并将结果压入栈顶i2f 将栈顶int型数值强制转换成float型数值并将结果压入栈顶i2d 将栈顶int型数值强制转换成do le型数值并将结果压入栈顶l2i 将栈顶long型数值强制转换成int型数值并将结果压入栈顶l2f 将栈顶long型数值强制转换成float型数值并将结果压入栈顶l2d 将栈顶long型数值强制转换成do le型数值并将结果压入栈顶f2i 将栈顶float型数值强制转换成int型数值并将结果压入栈顶f2l 将栈顶float型数值强制转换成long型数值并将结果压入栈顶f2d 将栈顶float型数值强制转换成do le型数值并将结果压入栈顶d2i 将栈顶do le型数值强制转换成int型数值并将结果压入栈顶d2l 将栈顶do le型数值强制转换成long型数值并将结果压入栈顶d2f 将栈顶do le型数值强制转换成float型数值并将结果压入栈顶i2b 将栈顶int型数值强制转换成byte型数值并将结果压入栈顶i2c 将栈顶int型数值强制转换成char型数值并将结果压入栈顶i2s 将栈顶int型数值强制转换成short型数值并将结果压入栈顶lcmp 比较栈顶两long型数值大小，并将结果（1，0，-1）压入栈顶fcmpl 比较栈顶两float型数值大小，并将结果（1，0，-1）压入栈顶；当其中一个数值为NaN时，将-1压入栈顶fcmpg 比较栈顶两float型数值大小，并将结果（1，0，-1）压入栈顶；当其中一个数值为NaN时，将1压入栈顶dcmpl 比较栈顶两do le型数值大小，并将结果（1，0，-1）压入栈顶；当其中一个数值为NaN时，将-1压入栈顶dcmpg 比较栈顶两do le型数值大小，并将结果（1，0，-1）压入栈顶；当其中一个数值为NaN时，将1压入栈顶ifeq 当栈顶int型数值等于0时跳转ifne 当栈顶int型数值不等于0时跳转iflt 当栈顶int型数值小于0时跳转ifge 当栈顶int型数值大于等于0时跳转ifgt 当栈顶int型数值大于0时跳转ifle 当栈顶int型数值小于等于0时跳转if_icmpeq 比较栈顶两int型数值大小，当结果等于0时跳转if_icmpne 比较栈顶两int型数值大小，当结果不等于0时跳转if_icmplt 比较栈顶两int型数值大小，当结果小于0时跳转if_icmpge 比较栈顶两int型数值大小，当结果大于等于0时跳转if_icmpgt 比较栈顶两int型数值大小，当结果大于0时跳转if_icmple 比较栈顶两int型数值大小，当结果小于等于0时跳转if_acmpeq 比较栈顶两引用型数值，当结果相等时跳转if_acmpne 比较栈顶两引用型数值，当结果不相等时跳转goto 无条件跳转jsr 跳转至指定16位offset位置，并将jsr下一条指令地址压入栈顶ret 返回至本地变量tableswitch 用于switch条件跳转，case值连续（可变长度指令）lookupswitch 用于switch条件跳转，case值不连续（可变长度指令ireturn 从当前方法返回intlreturn 从当前方法返回longfreturn 从当前方法返回floatdreturn 从当前方法返回do leareturn 从当前方法返回对象引用return 从当前方法返回voidgetstatic 获取指定类的静态域，并将其值压入栈顶putstatic 为指定的类的静态域赋值getfield 获取指定类的实例域，并将其值压入栈顶putfield 为指定的类的实例域赋值invokevirtual 调用实例方法invokespecial 调用超类构造方法，实例初始化方法，私有方法invokestatic 调用静态方法invokeinterface 调用接口方法– 无此指令new 创建一个对象，并将其引用值压入栈顶newarray 创建一个指定原始类型（如int, float, char…）的数组，并将其引用值压入栈顶anewarray 创建一个引用型（如类，接口，数组）的数组，并将其引用值压入栈顶arraylength 获得数组的长度值并压入栈顶athrow 将栈顶的异常抛出checkcast 检验类型转换，检验未通过将抛出ClassCastExceptioninstanceof 检验对象是否是指定的类的实例，如果是将1压入栈顶，否则将0压入栈顶monitorenter 获得对象的锁，用于同步方法或同步块monitorexit 释放对象的锁，用于同步方法或同步块wide &lt;待补充&gt;multianewarray 创建指定类型和指定维度的多维数组（执行该指令时，操作栈中必须包含各维度的长度值），并将其引用值压入栈顶ifnull 为null时跳转ifnonnull 不为null时跳转goto_w 无条件跳转（宽索引）jsr_w 跳转至指定32位offset位置，并将jsr_w下一条指令地址压入栈顶]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker入门之镜像仓库]]></title>
    <url>%2Farticle%2Fdocker-registry.html</url>
    <content type="text"><![CDATA[docker仓库类似于代码仓库，它是docker集中存放镜像文件的场所]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker入门之Dockerfile]]></title>
    <url>%2Farticle%2Fdockerfile.html</url>
    <content type="text"><![CDATA[我们可以使用Dockerfile创建镜像，下面对Dockerfile指令进行简单介绍。 FROMFROM指定基础镜像，若镜像不存在Docker会从docker hub中 来查找该镜像。FROM命令必须是Dockerfile的首个命令。 1FROM centos:7.2.1511 MAINTAINER维护者信息,一般用来指定作者,紧跟FROM命令 1MAINTAINER Ren Guangli &lt;renguangli@bonc.com.cn&gt; ADDDockerfile中的COPY指令和ADD指令都可以将主机上的资源复制或加入到容器镜像中，都是在构建镜像的过程中完成的。ADD指令不仅能够将构建命令所在的主机本地的文件或目录，而且能够将远程URL所对应的文件或目录，作为资源复制到镜像文件系统。如果源文件是identity, gzip, bzip2，xz，tar.gz，tgz等类型的压缩文件，会添加tar -x命令，自动解压 对于从远程URL获取资源的情况，由于ADD指令不支持认证，如果从远程获取资源需要认证，则只能使用RUN wget或RUN curl替代。另外，如果源路径的资源发生变化，则该ADD指令将使Docker Cache失效，Dockerfile中后续的所有指令都不能使用缓存。因此尽量将ADD指令放在Dockerfile的后面。 123# exec格式用法ADD [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;]ADD [&quot;hello.sh&quot;,&quot;docker.sh&quot;,&quot;/mnt&quot;] 适合路径中带有空格的情况123# shell格式用法ADD &lt;src&gt;... &lt;dest&gt;ADD hello.sh docker.sh /mnt 注意事项 源路径可以有多个 源路径是相对于执行build的相对路径 源路径如果是本地路径，必须是build上下文中的路径 源路径如果是一个目录，则该目录下的所有内容都将被加入到容器，但是该目录本身不会 目标路径必须是绝对路径，或相对于WORKDIR的相对路径 目标路径如果不存在，则会创建相应的完整路径 路径中可以使用通配符 COPY和ADD指令类似，只是不能从远端获取资源和自动解压压缩文件 ENV配置环境变量 12ENV &lt;key&gt; &lt;value&gt;ENV &lt;key&gt;=&lt;value&gt; ... 第二种格式可以设置多个键值对，推荐在一条ENV指令中设置多个键值对，因为这样产生一个缓存层。 1ENV JAVA_HOME=/mnt/jdk1.7 PATH=$JAVA_HOME/bin:$PATH CLASSPATH=.:$JAVA_HOME/lib EXPOSE1EXPOSE &lt;port&gt; [&lt;port&gt;...] 指定于外界交互的端口 1EXPOSE 8080 443 在容器启动时用-p传递参数，例如docker run -d -p 8088:8080 -p 8089:443 tomcat:7.0.81将容器内的8080绑定到本机的8088端口,443绑定到本机的8089端口 USER1USER root 指定运行容器时的用户名或 UID，后续的RUN、CMD、ENTRYPOINT也会使用指定用户。 WORKDIR1WORKDIR /path/to/workdir 为后续的RUN、CMD、ENTRYPOINT指令配置工作目录。可以使用多个WORKDIR指令，后续命令如果参数是相对路径，则会基于之前命令指定的路径 1234WORKDIR /aWORKDIR bWORKDIR cRUN pwd 最终路径是/a/b/c。 WORKDIR指令可以在ENV设置变量之后调用环境变量: 12ENV DIRPATH /pathWORKDIR $DIRPATH/$DIRNAME 最终路径则为 /path/$DIRNAME。 参考连接http://www.docker.org.cn/dockerppt/114.htmlhttp://www.cnblogs.com/sorex/p/6481407.htmlhttp://blog.csdn.net/taiyangdao/article/details/73222601]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker入门之容器]]></title>
    <url>%2Farticle%2Fdocker-container.html</url>
    <content type="text"><![CDATA[容器是docker的另一个核心概念，简单来说容器就是镜像的一个运行示例。 查看容器使用docker ps命令查看运行着的容器 123[root@localhost ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES229929eb660f renguangli/nginx:1.0 &quot;nginx -g &apos;daemon off&quot; 17 hours ago Up 3 seconds 0.0.0.0:80-&gt;80/tcp nginx 使用docker ps -a命令查看所有的容器 1234[root@localhost ~]# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES229929eb660f renguangli/nginx:1.0 &quot;nginx -g &apos;daemon off&quot; 17 hours ago Up 3 seconds 0.0.0.0:80-&gt;80/tcp nginx3ceb621f4aa9 jenkins &quot;/bin/tini -- /usr/lo&quot; About an hour ago Exited (137) 48 seconds ago elated_davinci 使用docker ps -q命令查看运行着的容器Id 使用docker create image:tag name命令创建一个容器并给容器一个name，例如 12[root@localhost ~]# docker create nginx:latest nginxfd47cedfcce5cd2879ef65b342b1cd4130cbcc081cec532ff7af1744ad589116 如果不加name的话随机分配一个名字 启动容器使用docker start 容器名称或容器ID来启动一个容器，例如 123[root@localhost ~]# docker ps -a229929eb660f renguangli/nginx:1.0 &quot;nginx -g &apos;daemon off&quot; 17 hours ago Exited (0) 8 seconds ago nginx[root@localhost ~]# docker start nginx 或者 docker start 229929eb660f 新建并启动容器创建容器后可以用docker start命令启动容器，也可以用docker run命令直接新建并启动容器，docker run相当于先执行docker create命令在执行docker start名利。例如，输出一个”hello docker” 12[root@localhost ~]# docker run ubuntu echo &quot;hello docker&quot;hello docker 这跟在本次执行echo &quot;hello docker&quot;几乎没有任何区别，但是在执行docker run命令时经历了复杂的操作： 检查本地是否存在指定的镜像，，不存在就从共有仓库下载 利用镜像创建并启动一个容器 分配一个文件系统给容器，并在只读的镜像层外面挂在一个可读写层 从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中 从王桥的地址池中配置一个IP地址给容器 执行用户指定的应用程序 执行完毕后容器自动终止 docker run -d命令会让容器在后台运行docker logs名利可以查看容器日志docker logs -f命令可以像tail -f命令一样查看容器日志 终止容器使用docker stop 容器名或容器ID命令停止一个容器 1234[root@localhost html]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES16555d4ebdf0 nginx:1.10.0 &quot;nginx -g &apos;daemon off&quot; 47 minutes ago Up 8 seconds 0.0.0.0:80-&gt;80/tcp jolly_goodall[root@localhost html]# docker stop 16555d4ebdf0 或者 docker stop jolly_goodall docker stop命令首先想容器发送SIGKILL的信号，等待一段时间后（默认10秒）在发送SIGKILL信号来终止容器docker kill 命令会直接发送SIGKILL信号来终止容器 终止的容器可以使用docer start来启动一个容器 运行着的容器可以使用docker restart来重启容器]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker入门之镜像]]></title>
    <url>%2Farticle%2Fdocker-image.html</url>
    <content type="text"><![CDATA[docker镜像类似于虚拟机镜像，可以将它理解为一个只读的模板。例如，一个镜像可以包含一个基本的操作系统，里面安装了tomcat(或者其它软件)，我们把它称为tomcat镜像。镜像是创建docker容器的基础。通过版本管理和增量的文件系统，docker提供了十分简单的机制来创建和更新的现有的镜像，也可以从镜像仓库里pull镜像，就像git pull代码一样。 获取镜像镜像是容器运行的前提条件，官方DockerHub 镜像仓库提供了很多个镜像提供大家开放下载。我们可以直接使用docker pull命令直接从Docker Hub镜像源下载镜像命令格式：docker pull name:tagname为镜像名称，tag为镜像的标签(通常用来表示版本信息)\获取一个Ubuntu 14.04系统镜像可以使用docker pull ubuntu:14.041[root@localhost ~]# docker pull ubuntu:14.04 如果不指定tag，则默认会选择latest标签，下载仓库中最新版本的镜像。严格地讲仓库名称还要添加镜像地址(即registry，注册服务器）为前缀，我们使用的是官方Docker Hub，所以前缀可以省略,完整命令为docker pull docker.io/library/ubuntu:14.04如果下载非官方的镜像，仓库名称前要指定完整的仓库地址。例如我们从网易的镜像源下载ubuntu 14.04 正确命令为 1docker pull hub.c.163.com/ubuntu:latest pull子命令支持的选项主要包括-a, --all-tags=true|false 是否获取从那个库中的所有镜像，默认为false，具体的选项可以通过 docker pull --help 命令查看。有了镜像后，我们就可以以这个镜像为基础启动一个容器来运行。以上面的 ubuntu:14.04 为例，如果我们打算启动里面的 bash 并且进行交互式操作的话，可以执行下面的命令。 1234567891011121314[root@localhost ~]# docker run -it --rm ubuntu:14.04 bashroot@21762fe64d8f:/# cat /etc/os-release NAME=&quot;Ubuntu&quot;VERSION=&quot;14.04.5 LTS, Trusty Tahr&quot;ID=ubuntuID_LIKE=debianPRETTY_NAME=&quot;Ubuntu 14.04.5 LTS&quot;VERSION_ID=&quot;14.04&quot;HOME_URL=&quot;http://www.ubuntu.com/&quot;SUPPORT_URL=&quot;http://help.ubuntu.com/&quot;BUG_REPORT_URL=&quot;http://bugs.launchpad.net/ubuntu/&quot;root@21762fe64d8f:/# exitexit[root@localhost ~]# docker run 就是运行容器的命令，我们这里简要的说明一下上面用到的参数。-it：这是两个参数，一个是 -i：交互式操作，一个是 -t 终端。我们这里打算进入 bash 执行一些命令并查看返回结果，因此我们需要交互式终端。--rm：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 docker rm 我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用 --rm 可以避免浪费空间。ubuntu:14.04：这是指用 ubuntu:14.04 镜像为基础来启动容器。bash：放在镜像名后的命令，这里我们希望有个交互式 Shell，因此用的是 bash。进入容器后，我们可以在 Shell 下操作，执行任何所需的命令。这里，我们执行了 cat /etc/os-release，这是 Linux 常用的查看当前系统版本的命令，从返回的结果可以看到容器内是 Ubuntu 14.04.5 LTS 系统。最后我们通过 exit 退出了这个容器。 查看镜像信息使用docker images命令可以查看本地已存在镜像1234[root@localhost ~]# docker images REPOSITORY TAG IMAGE ID CREATED SIZEdocker.io/ubuntu 14.04 ccc7a11d65b1 4 weeks ago 120.1 MBdocker.io/ubuntu latest ccc7a11d65b1 4 weeks ago 120.1 MB 在列出的信息中有5个字段，分别是镜像来自哪个仓库、标签、镜像ID、创建时间。 docker images -a列出所有镜像文件 docker images -q仅列出镜像ID docker images -f dangling=true列出没有别使用的镜像 使用docker tag命令给镜像添加新标签 1[root@localhost ~]# docker tag ubuntu:14.04 ubuntu:14 然后使用docker images查看镜像,多了一个拥有ubuntu:14标签的镜像12345[root@localhost ~]# docker images REPOSITORY TAG IMAGE ID CREATED SIZEdocker.io/ubuntu 14 ccc7a11d65b1 4 weeks ago 120.1 MBdocker.io/ubuntu 14.04 ccc7a11d65b1 4 weeks ago 120.1 MBdocker.io/ubuntu latest ccc7a11d65b1 4 weeks ago 120.1 MB 使用docker inspect命令查看镜像详细信息。 包括制作者、适应架构、各层的数字摘要等等信息。 使用docker history name:tag查看镜像历史比如查看ubuntu:latest镜像的创建过程12345678[root@yangjian06 wso2am]# docker history ubuntu:latestIMAGE CREATED CREATED BY SIZE COMMENTccc7a11d65b1 5 weeks ago /bin/sh -c #(nop) CMD [&quot;/bin/bash&quot;] 0 B &lt;missing&gt; 5 weeks ago /bin/sh -c mkdir -p /run/systemd &amp;&amp; echo &apos;doc 7 B &lt;missing&gt; 5 weeks ago /bin/sh -c sed -i &apos;s/^#\s*\(deb.*universe\)$/ 2.759 kB &lt;missing&gt; 5 weeks ago /bin/sh -c rm -rf /var/lib/apt/lists/* 0 B &lt;missing&gt; 5 weeks ago /bin/sh -c set -xe &amp;&amp; echo &apos;#!/bin/sh&apos; &gt; /u 745 B &lt;missing&gt; 5 weeks ago /bin/sh -c #(nop) ADD file:39d3593ea220e686d5 120.1 MB 过长的命令被截断了，可以使用--no-trunc选项输出完整命令 搜索镜像使用docker search命令可以搜索镜像库里中共享的镜像，默认搜索官方仓库的镜像。比如我们搜索nginx镜像 123456789[root@yangjian06 wso2am]# docker search -s 40 nginxINDEX NAME DESCRIPTION STARS OFFICIAL AUTOMATEDdocker.io docker.io/nginx Official build of Nginx. 6865 [OK] docker.io docker.io/jwilder/nginx-proxy Automated Nginx reverse proxy for docker c... 1124 [OK]docker.io docker.io/richarvey/nginx-php-fpm Container running Nginx + PHP-FPM capable ... 439 [OK]docker.io docker.io/jrcs/letsencrypt-nginx-proxy-companion LetsEncrypt container to use with nginx as... 223 [OK]docker.io docker.io/kong Open-source Microservice &amp; API Management ... 112 [OK] docker.io docker.io/webdevops/php-nginx Nginx with PHP-FPM 90 [OK]docker.io docker.io/kitematic/hello-world-nginx A light-weight nginx container that demons... 85 输出结果将按照星级评级进行排训，-s参数表示星级40以上的nginx镜像，支持的参数还有 --automated=true|false 仅显示自动创建的镜像，默认为否 --no-trunc=true|false 输出信息不截断提示，默认为否删除镜像命令docker rmi可以删除镜像使用标签删除镜像，例如我们删除ubuntu:14镜像 12[root@localhost ~]# docker rmi ubuntu:14Untagged: ubuntu:14 如果该镜像有多个标签的话删除的只是标签并不会删除镜像。如果只有一个标签的话docker rmi命令会彻底删除镜像。 使用id删除镜像使用命令docker rmi ID命令可以删除镜像 当有该镜像创建的容器存在时，镜像是无法删除的。如果要强行删除的话可以使用docker rmi -f ID 创建镜像创建镜像的方法主要有三种：基于已有镜像的容器创建，基于本地模板导入，基于dockerfile创建镜像 基于已有镜像的容器创建该方法主要是用docker commit命令创建镜像，主要参数为 -a，–auther=”” 作者信息 -m, –message=”” 提交信息 首先我们启动一个nginx镜像,然后进入容器，创建一个test文件，退出。 123456[root@localhost ~]# docker run -d -p 80:80 nginx00fb093d0ec2044f6a5d62fe2aa64c487e427456bd53cb6dc8b6462be4e25167[root@localhost ~]# docker exec -it 00fb093d0 bash root@00fb093d0ec2:/# touch testroot@00fb093d0ec2:/# exit[root@localhost ~]# 这时容器已发生了改变，使用docker commit命令创建一个新的镜像 12[root@localhost ~]# docker commit -a rgl -m &quot;add a new file&quot; 00fb093d0ec2 test:0.1sha256:bcaa64525c2bde4e1329f7b28bc2c98b2947f83a5cb0efff6e9d968a85618930 创建成功的话会返回新镜像的id。 保存和加载镜像如果要存出镜像到本地文件，可以使用docker save命令 1[root@localhost ~]# docker save -o nginx.tar nginx:latest 这样就可以通过复制该镜像文件分享给其他人如果要把镜像文件载入到本地镜像库，使用命令docker load。 12[root@localhost ~]# docker load --input nginx.tar Loaded image: nginx:latest 或者1234[root@localhost ~]# docker save nginx:latest &gt; nginx.tar Loaded image: nginx:latest[root@localhost ~]# docker load &lt; nginx.tar Loaded image: nginx:latest 上传镜像使用docker push命令上传镜像到仓库，默认上传到Docker官方仓库（需要登录）。例如我们自制的nginx：1.10.0镜像上传，首先我们要添加新的标签user/nginx:1.10.0 ,然后用docker push上传镜像，user改成你的用户名。 12345[root@localhost ~]# docker push user/nginx:1.10.0The push refers to a repository [docker.io/user/nginx]110566462efa: Mounted from library/nginx 305e2b6ef454: Mounted from library/nginx 1.10.0: digest: sha256:d8565c25b654da69bc9b837a0dee713c988f0276e90564aa8fd12ebf4c2ff11e size: 948]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker入门之安装]]></title>
    <url>%2Farticle%2Fdocker-deploy.html</url>
    <content type="text"><![CDATA[由于本人系统是centos,所以只演示在centos下的docke安装。其他系统请参考docker官方文档 Centos下安装docker系统要求：64为操作系统，内核版本至少为3.10docker目前支持Centos6.5及以上的版本 yum安装执行以下命令添加docker的yum源1yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 对于centos7，Centos-Extras源中已经内置了docker，可以直接通过yum安装1yum install -y docker 启动docker1systemctl start docker.service 设置docker开启自启动1systemclt enable docker.service]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker入门之简介]]></title>
    <url>%2Farticle%2Fdocker-summary.html</url>
    <content type="text"><![CDATA[什么是docker docker是一个开源的应用容器引擎; docker是一个开源的软件部署解决方案； docker也是轻量级的应用容器框架； docker可以打包、发布、运行任何的应用。 下面的图片比较了 docker 和传统虚拟化方式的不同之处。传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。 为什么要用docker作为一种新兴的虚拟化方式，docker 跟传统的虚拟化方式相比具有众多的优势。 更高效的利用系统资源由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，docker 对系统资源的利用率更高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。 更快速的启动时间传统的虚拟机技术启动应用服务往往需要数分钟，而 docker 容器应用，由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。 一致的运行环境开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环境不一致，导致有些 bug 并未在开发过程中被发现。而 docker 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 「这段代码在我机器上没问题啊」 这类问题。 持续交付和部署对开发和运维（DevOps）人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。使用 docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过 dockerfile 来进行镜像构建，并结合 持续集成(Continuous Integration) 系统进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合 持续部署(Continuous Delivery/Deployment) 系统进行自动部署。而且使用 dockerfile 使镜像构建透明化，不仅仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需条件，帮助更好的生产环境中部署该镜像。 更轻松的迁移由于 docker 确保了执行环境的一致性，使得应用的迁移更加容易。docker 可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。 更轻松的维护和扩展docker 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。此外，docker 团队同各个开源项目团队一起维护了一大批高质量的官方镜像，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本。 对比传统虚拟机总结 特性 容器 虚拟机 启动 秒级 分钟级 硬盘使用 一般为 MB 一般为 GB 性能 接近原生 弱于 系统支持量 单机支持上千个容器 一般几十个 百度百科]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo之博客搭建]]></title>
    <url>%2Farticle%2Fhexo.html</url>
    <content type="text"><![CDATA[什么是 Hexo？Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页，详情请看hexo官网。在使用之前电脑必须安装nodejs和git 安装hexo1234$ npm install -g hexo-cli$ hexo init blog$ cd blog$ npm install 创建新文章1$ hexo new "文章标题" 如果文章标题之间有空格要用引号引起来 运行1$ hexo server 打开浏览器，在地址栏输入 localhost:4000就会出现如下界面]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每天学点儿linux--vi编辑器的使用]]></title>
    <url>%2Farticle%2Flinux-vi.html</url>
    <content type="text"><![CDATA[vi编辑器是Linux系统下标准的编辑器，一般linux都没有桌面环境，平常修改一些配置文件，编写脚本对于vi编辑器来说都很方便，所以我们有必要学会并熟练使用它。vi编辑器可以分为三种状态，分别是命令模式、插入模式和底行模式 命令行模式：控制屏幕光标的移动、字符、字或行的删除，移动复制某区段及进入插入模式下，或者到底行模式。 插入模式：只有在插入模式下，才可以做文字输入，按「ESC」键可回到命令行模式。 底行模式：将文件保存或退出vi，也可以设置编辑环境，如寻找字符串、列出行号……等。 下面列举一些常用命令和技巧 基本使用我们如何进入vi编辑器呢？输入vi fileName命令进入vi编辑器，这时处于命令行模式。在命令模式下按下i字母就会进入插入模式，这时就可以对对文件进行编辑了。那我们如何退出vi编辑器呢？在命令行模式下，按一下 :冒号键进入底行模式 :w保存但不退出。 :w fileName文件另存为filename。 :wq保存并退出。 :q退出但不保存。在末尾加入！表示强制执行，例如:q!表示强制退出但不保存。 命令行模式功能键进入插入模式的几种方法。 按i进入插入模式后，光标当前位置开始输入文件； 按大写I进入插入模式后，光标所在行开始位置开始输入文件 按a进入插入模式后，光标所在位置的下一个位置开始输入文字； 按A进入插入模式后，光标所在行末尾开始输入文字； 按o进入插入模式后，在当前行下一行插入新的一行，从行首开始输入文字。 按O进入插入模式后，在当前行上一行是插入新的一行，从行首开始输入文字。 移动光标vi可以直接用键盘上的光标来上下左右移动，但正规的vi是用小写英文字母hjkl，分别控制光标左、下、上、右移一格。其他移动光标的功能键 ctrl + b屏幕往“后”移动一页。 ctrl + f屏幕往“前”移动一页。 ctrl + u屏幕往“后”移动半页 ctrl + d屏幕往“前”移动半页。 home,^,0移到行首。 end,\$移到行尾 gg移到文件开头。 G移到文件最后。 w光标跳到下个字的开头 e光标跳到下个字的字尾 b光标回到上个字的开头 #l光标移到该行的第#个位置，如：5l,56l。 删除文字 x每按一次，删除光标所在位置的“后面”一个字符。 #x：例如，「6x」表示删除光标所在位置的“后面”6个字符。 X大写的X，每按一次，删除光标所在位置的“前面”一个字符。 #X例如，「20X」表示删除光标所在位置的“前面”20个字符。 dd删除光标所在行。 #dd从光标所在行开始删除#行 复制 yw将光标所在之处到字尾的字符复制到缓冲区中。 #wy复制#个字到缓冲区 yy复制光标所在行到缓冲区。 #yy例如，「6yy」表示拷贝从光标所在的该行“往下数”6行文字。 p将缓冲区内的字符贴到光标所在位置。注意：所有与“y”有关的复制命令都必须与“p”配合才能完成复制与粘贴功能。 替换 r替换光标所在处的字符。 R替换光标所到之处的字符，直到按下「ESC」键为止。 撤销 u如果您误执行一个命令，可以马上按下u，回到上一个操作。按多次“u”可以执行多次回复。 更改 cw更改光标所在处的字到字尾处 c#w例如,c3w表示更改3个字 跳至指定的行 ctrl + g列出光标所在行的行号。 #G例如，10G，表示移动光标至文章的第15行行首。 底行模式下命令简介 在使用底行模式之前，请记住先按「ESC」键确定您已经处于命令行模式下后，再按:冒号即可进入底行模式。 列出行号 set nu输入set nu后，会在文件中的每一行前面列出行号。 跳到文件中的某一行 #号表示一个数字，在冒号后输入一个数字，再按回车键就会跳到该行了，如输入数字15，再回车，就会跳到文章的第15行。 查找字符 /关键字先按/键，再输入您想寻找的字符，如果第一次找的关键字不是您想要的，可以一直按n会往后寻找到您要的关键字为止。 ?关键字先按?键，再输入您想寻找的字符，如果第一次找的关键字不是您想要的，可以一直按n会往前寻找到您要的关键字为止。 保存文件 w在冒号输入字母w就可以将文件保存起来。 离开vi q按「q」就是退出，如果无法离开vi，可以在q跟一个!强制离开vi。 qw一般建议离开时，搭配w一起使用，这样在退出的时候还可以保存文件。]]></content>
      <tags>
        <tag>每天学点儿linux</tag>
      </tags>
  </entry>
</search>
