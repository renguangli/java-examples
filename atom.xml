<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dali`s Blogs</title>
  
  <subtitle>大力的技术博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://renguangli.com/"/>
  <updated>2018-07-12T10:26:34.320Z</updated>
  <id>https://renguangli.com/</id>
  
  <author>
    <name>大力</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>docker入门之Dockerfile</title>
    <link href="https://renguangli.com/article/dockerfile.html"/>
    <id>https://renguangli.com/article/dockerfile.html</id>
    <published>2017-10-31T10:27:13.000Z</published>
    <updated>2018-07-12T10:26:34.320Z</updated>
    
    <content type="html"><![CDATA[<p>我们可以使用Dockerfile创建镜像，下面对Dockerfile指令进行简单介绍。</p><h3 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h3><p><code>FROM</code>指定基础镜像，若镜像不存在Docker会从docker hub中 来查找该镜像。<code>FROM</code>命令必须是Dockerfile的首个命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FROM centos:7.2.1511</span><br></pre></td></tr></table></figure><h3 id="MAINTAINER"><a href="#MAINTAINER" class="headerlink" title="MAINTAINER"></a>MAINTAINER</h3><p>维护者信息,一般用来指定作者,紧跟<code>FROM</code>命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MAINTAINER Ren Guangli &lt;renguangli@bonc.com.cn&gt;</span><br></pre></td></tr></table></figure><h3 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h3><p>Dockerfile中的<code>COPY</code>指令和<code>ADD</code>指令都可以将主机上的资源复制或加入到容器镜像中，都是在构建镜像的过程中完成的。<code>ADD</code>指令不仅能够将构建命令所在的主机本地的文件或目录，而且能够将远程URL所对应的文件或目录，作为资源复制到镜像文件系统。如果源文件是identity, gzip, bzip2，xz，tar.gz，tgz等类型的压缩文件，会添加tar -x命令，自动解压</p><blockquote><p>对于从远程URL获取资源的情况，由于ADD指令不支持认证，如果从远程获取资源需要认证，则只能使用RUN wget或RUN curl替代。<br>另外，如果源路径的资源发生变化，则该ADD指令将使Docker Cache失效，Dockerfile中后续的所有指令都不能使用缓存。因此尽量将ADD指令放在Dockerfile的后面。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># exec格式用法</span><br><span class="line">ADD [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;]</span><br><span class="line">ADD [&quot;hello.sh&quot;,&quot;docker.sh&quot;,&quot;/mnt&quot;]</span><br></pre></td></tr></table></figure><p>适合路径中带有空格的情况<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># shell格式用法</span><br><span class="line">ADD &lt;src&gt;... &lt;dest&gt;</span><br><span class="line">ADD hello.sh docker.sh /mnt</span><br></pre></td></tr></table></figure></p><p>注意事项</p><ul><li>源路径可以有多个</li><li>源路径是相对于执行build的相对路径</li><li>源路径如果是本地路径，必须是build上下文中的路径</li><li>源路径如果是一个目录，则该目录下的所有内容都将被加入到容器，但是该目录本身不会</li><li>目标路径必须是绝对路径，或相对于WORKDIR的相对路径</li><li>目标路径如果不存在，则会创建相应的完整路径</li><li>路径中可以使用通配符</li></ul><h3 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h3><p>和<code>ADD</code>指令类似，只是不能从远端获取资源和自动解压压缩文件</p><h3 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h3><p>配置环境变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENV &lt;key&gt; &lt;value&gt;</span><br><span class="line">ENV &lt;key&gt;=&lt;value&gt; ...</span><br></pre></td></tr></table></figure><p>第二种格式可以设置多个键值对，推荐在一条<code>ENV</code>指令中设置多个键值对，因为这样产生一个缓存层。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENV JAVA_HOME=/mnt/jdk1.7 PATH=$JAVA_HOME/bin:$PATH CLASSPATH=.:$JAVA_HOME/lib</span><br></pre></td></tr></table></figure><h3 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPOSE &lt;port&gt; [&lt;port&gt;...]</span><br></pre></td></tr></table></figure><p>指定于外界交互的端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPOSE 8080 443</span><br></pre></td></tr></table></figure><p>在容器启动时用-p传递参数，例如<code>docker run -d -p 8088:8080 -p 8089:443 tomcat:7.0.81</code>将容器内的8080绑定到本机的8088端口,443绑定到本机的8089端口</p><h3 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USER root</span><br></pre></td></tr></table></figure><p>指定运行容器时的用户名或 UID，后续的RUN、CMD、ENTRYPOINT也会使用指定用户。</p><h3 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WORKDIR /path/to/workdir</span><br></pre></td></tr></table></figure><p>为后续的RUN、CMD、ENTRYPOINT指令配置工作目录。可以使用多个WORKDIR指令，后续命令如果参数是相对路径，则会基于之前命令指定的路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">WORKDIR /a</span><br><span class="line">WORKDIR b</span><br><span class="line">WORKDIR c</span><br><span class="line">RUN pwd</span><br></pre></td></tr></table></figure><p>最终路径是/a/b/c。</p><p>WORKDIR指令可以在ENV设置变量之后调用环境变量:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENV DIRPATH /path</span><br><span class="line">WORKDIR $DIRPATH/$DIRNAME</span><br></pre></td></tr></table></figure><p>最终路径则为 <code>/path/$DIRNAME</code>。</p><h2 id="参考连接"><a href="#参考连接" class="headerlink" title="参考连接"></a>参考连接</h2><p><a href="http://www.docker.org.cn/dockerppt/114.html" target="_blank" rel="noopener">http://www.docker.org.cn/dockerppt/114.html</a><br><a href="http://www.cnblogs.com/sorex/p/6481407.html" target="_blank" rel="noopener">http://www.cnblogs.com/sorex/p/6481407.html</a><br><a href="http://blog.csdn.net/taiyangdao/article/details/73222601" target="_blank" rel="noopener">http://blog.csdn.net/taiyangdao/article/details/73222601</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们可以使用Dockerfile创建镜像，下面对Dockerfile指令进行简单介绍。&lt;/p&gt;
&lt;h3 id=&quot;FROM&quot;&gt;&lt;a href=&quot;#FROM&quot; class=&quot;headerlink&quot; title=&quot;FROM&quot;&gt;&lt;/a&gt;FROM&lt;/h3&gt;&lt;p&gt;&lt;code&gt;FROM&lt;
      
    
    </summary>
    
    
      <category term="docker" scheme="https://renguangli.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker入门之容器</title>
    <link href="https://renguangli.com/article/docker-container.html"/>
    <id>https://renguangli.com/article/docker-container.html</id>
    <published>2017-09-15T13:47:24.000Z</published>
    <updated>2018-07-12T10:26:34.431Z</updated>
    
    <content type="html"><![CDATA[<p>容器是docker的另一个核心概念，简单来说容器就是镜像的一个运行示例。</p><h3 id="查看容器"><a href="#查看容器" class="headerlink" title="查看容器"></a>查看容器</h3><p>使用<code>docker ps</code>命令查看运行着的容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker ps</span><br><span class="line">CONTAINER ID        IMAGE                  COMMAND                  CREATED             STATUS              PORTS                NAMES</span><br><span class="line">229929eb660f        renguangli/nginx:1.0   &quot;nginx -g &apos;daemon off&quot;   17 hours ago        Up 3 seconds        0.0.0.0:80-&gt;80/tcp   nginx</span><br></pre></td></tr></table></figure><p>使用<code>docker ps -a</code>命令查看所有的容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE                  COMMAND                  CREATED             STATUS              PORTS                NAMES</span><br><span class="line">229929eb660f        renguangli/nginx:1.0   &quot;nginx -g &apos;daemon off&quot;   17 hours ago        Up 3 seconds        0.0.0.0:80-&gt;80/tcp   nginx</span><br><span class="line">3ceb621f4aa9        jenkins             &quot;/bin/tini -- /usr/lo&quot;   About an hour ago   Exited (137) 48 seconds ago                            elated_davinci</span><br></pre></td></tr></table></figure><p>使用<code>docker ps -q</code>命令查看运行着的容器Id</p><p>使用<code>docker create image:tag name</code>命令创建一个容器并给容器一个name，例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker create nginx:latest nginx</span><br><span class="line">fd47cedfcce5cd2879ef65b342b1cd4130cbcc081cec532ff7af1744ad589116</span><br></pre></td></tr></table></figure><p>如果不加name的话随机分配一个名字</p><h3 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h3><p>使用<code>docker start 容器名称或容器ID</code>来启动一个容器，例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker ps -a</span><br><span class="line">229929eb660f        renguangli/nginx:1.0   &quot;nginx -g &apos;daemon off&quot;   17 hours ago        Exited (0) 8 seconds ago                        nginx</span><br><span class="line">[root@localhost ~]# docker start nginx 或者 docker start 229929eb660f</span><br></pre></td></tr></table></figure><h3 id="新建并启动容器"><a href="#新建并启动容器" class="headerlink" title="新建并启动容器"></a>新建并启动容器</h3><p>创建容器后可以用<code>docker start</code>命令启动容器，也可以用<code>docker run</code>命令直接新建并启动容器，<code>docker run</code>相当于先执行<code>docker create</code>命令在执行<code>docker start</code>名利。例如，输出一个”hello docker”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker run ubuntu echo &quot;hello docker&quot;</span><br><span class="line">hello docker</span><br></pre></td></tr></table></figure><p>这跟在本次执行<code>echo &quot;hello docker&quot;</code>几乎没有任何区别，但是在执行<code>docker run</code>命令时经历了复杂的操作：</p><ul><li>检查本地是否存在指定的镜像，，不存在就从共有仓库下载</li><li>利用镜像创建并启动一个容器</li><li>分配一个文件系统给容器，并在只读的镜像层外面挂在一个可读写层</li><li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中</li><li>从王桥的地址池中配置一个IP地址给容器</li><li>执行用户指定的应用程序</li><li>执行完毕后容器自动终止</li></ul><p><code>docker run -d</code>命令会让容器在后台运行<br><code>docker logs</code>名利可以查看容器日志<br><code>docker logs -f</code>命令可以像<code>tail -f</code>命令一样查看容器日志</p><h3 id="终止容器"><a href="#终止容器" class="headerlink" title="终止容器"></a>终止容器</h3><p>使用<code>docker stop 容器名或容器ID</code>命令停止一个容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost html]# docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                NAMES</span><br><span class="line">16555d4ebdf0        nginx:1.10.0        &quot;nginx -g &apos;daemon off&quot;   47 minutes ago      Up 8 seconds        0.0.0.0:80-&gt;80/tcp   jolly_goodall</span><br><span class="line">[root@localhost html]# docker stop 16555d4ebdf0 或者 docker stop jolly_goodall</span><br></pre></td></tr></table></figure><blockquote><p>docker stop命令首先想容器发送SIGKILL的信号，等待一段时间后（默认10秒）在发送SIGKILL信号来终止容器<br>docker kill 命令会直接发送SIGKILL信号来终止容器</p></blockquote><p>终止的容器可以使用<code>docer start</code>来启动一个容器</p><p>运行着的容器可以使用<code>docker restart</code>来重启容器</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;容器是docker的另一个核心概念，简单来说容器就是镜像的一个运行示例。&lt;/p&gt;
&lt;h3 id=&quot;查看容器&quot;&gt;&lt;a href=&quot;#查看容器&quot; class=&quot;headerlink&quot; title=&quot;查看容器&quot;&gt;&lt;/a&gt;查看容器&lt;/h3&gt;&lt;p&gt;使用&lt;code&gt;docker ps&lt;
      
    
    </summary>
    
    
      <category term="docker" scheme="https://renguangli.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker入门之镜像</title>
    <link href="https://renguangli.com/article/docker-image.html"/>
    <id>https://renguangli.com/article/docker-image.html</id>
    <published>2017-09-13T13:45:25.000Z</published>
    <updated>2018-07-12T10:26:34.241Z</updated>
    
    <content type="html"><![CDATA[<p>docker镜像类似于虚拟机镜像，可以将它理解为一个只读的模板。例如，一个镜像可以包含一个基本的操作系统，里面安装了tomcat(或者其它软件)，我们把它称为tomcat镜像。镜像是创建docker容器的基础。通过版本管理和增量的文件系统，docker提供了十分简单的机制来创建和更新的现有的镜像，也可以从镜像仓库里pull镜像，就像git  pull代码一样。</p><h2 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h2><p>镜像是容器运行的前提条件，<a href="https://hub.docker.com/" target="_blank" rel="noopener">官方DockerHub</a> 镜像仓库提供了很多个镜像提供大家开放下载。我们可以直接使用<code>docker pull</code>命令直接从Docker Hub镜像源下载镜像<br>命令格式：<code>docker pull name:tag</code>name为镜像名称，tag为镜像的标签(通常用来表示版本信息)\<br>获取一个Ubuntu 14.04系统镜像可以使用<code>docker pull ubuntu:14.04</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker pull ubuntu:14.04</span><br></pre></td></tr></table></figure></p><p>如果不指定tag，则默认会选择latest标签，下载仓库中最新版本的镜像。<br>严格地讲仓库名称还要添加镜像地址(即registry，注册服务器）为前缀，我们使用的是官方Docker Hub，所以前缀可以省略,完整命令为docker pull <code>docker.io/library/ubuntu:14.04</code><br>如果下载非官方的镜像，仓库名称前要指定完整的仓库地址。例如我们从网易的镜像源下载ubuntu 14.04 正确命令为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull hub.c.163.com/ubuntu:latest</span><br></pre></td></tr></table></figure><p>pull子命令支持的选项主要包括<code>-a, --all-tags=true|false</code> 是否获取从那个库中的所有镜像，默认为false，具体的选项可以通过 <code>docker pull --help</code> 命令查看。有了镜像后，我们就可以以这个镜像为基础启动一个容器来运行。以上面的 ubuntu:14.04 为例，如果我们打算启动里面的 bash 并且进行交互式操作的话，可以执行下面的命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker run -it --rm ubuntu:14.04 bash</span><br><span class="line">root@21762fe64d8f:/# cat /etc/os-release </span><br><span class="line">NAME=&quot;Ubuntu&quot;</span><br><span class="line">VERSION=&quot;14.04.5 LTS, Trusty Tahr&quot;</span><br><span class="line">ID=ubuntu</span><br><span class="line">ID_LIKE=debian</span><br><span class="line">PRETTY_NAME=&quot;Ubuntu 14.04.5 LTS&quot;</span><br><span class="line">VERSION_ID=&quot;14.04&quot;</span><br><span class="line">HOME_URL=&quot;http://www.ubuntu.com/&quot;</span><br><span class="line">SUPPORT_URL=&quot;http://help.ubuntu.com/&quot;</span><br><span class="line">BUG_REPORT_URL=&quot;http://bugs.launchpad.net/ubuntu/&quot;</span><br><span class="line">root@21762fe64d8f:/# exit</span><br><span class="line">exit</span><br><span class="line">[root@localhost ~]#</span><br></pre></td></tr></table></figure><p>docker run 就是运行容器的命令，我们这里简要的说明一下上面用到的参数。<br><code>-it</code>：这是两个参数，一个是 <code>-i</code>：交互式操作，一个是 <code>-t</code> 终端。我们这里打算进入 bash 执行一些命令并查看返回结果，因此我们需要交互式终端。<code>--rm</code>：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 <code>docker rm</code> 我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用 <code>--rm</code> 可以避免浪费空间。<br>ubuntu:14.04：这是指用 ubuntu:14.04 镜像为基础来启动容器。<br>bash：放在镜像名后的命令，这里我们希望有个交互式 Shell，因此用的是 bash。<br>进入容器后，我们可以在 Shell 下操作，执行任何所需的命令。这里，我们执行了 <code>cat /etc/os-release</code>，这是 Linux 常用的查看当前系统版本的命令，从返回的结果可以看到容器内是 Ubuntu 14.04.5 LTS 系统。最后我们通过 <code>exit</code> 退出了这个容器。</p><h2 id="查看镜像信息"><a href="#查看镜像信息" class="headerlink" title="查看镜像信息"></a>查看镜像信息</h2><p>使用<code>docker images</code>命令可以查看本地已存在镜像<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker images </span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">docker.io/ubuntu    14.04               ccc7a11d65b1        4 weeks ago         120.1 MB</span><br><span class="line">docker.io/ubuntu    latest              ccc7a11d65b1        4 weeks ago         120.1 MB</span><br></pre></td></tr></table></figure></p><p>在列出的信息中有5个字段，分别是镜像来自哪个仓库、标签、镜像ID、创建时间。</p><ul><li><code>docker images -a</code>列出所有镜像文件</li><li><code>docker images -q</code>仅列出镜像ID</li><li><code>docker images -f dangling=true</code>列出没有别使用的镜像</li></ul><p>使用<code>docker tag</code>命令给镜像添加新标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker tag ubuntu:14.04 ubuntu:14</span><br></pre></td></tr></table></figure><p>然后使用<code>docker images</code>查看镜像,多了一个拥有ubuntu:14标签的镜像<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker images </span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">docker.io/ubuntu    14                  ccc7a11d65b1        4 weeks ago         120.1 MB</span><br><span class="line">docker.io/ubuntu    14.04               ccc7a11d65b1        4 weeks ago         120.1 MB</span><br><span class="line">docker.io/ubuntu    latest              ccc7a11d65b1        4 weeks ago         120.1 MB</span><br></pre></td></tr></table></figure></p><p>使用<code>docker inspect</code>命令查看镜像详细信息。  包括制作者、适应架构、各层的数字摘要等等信息。</p><p>使用<code>docker history name:tag</code>查看镜像历史<br>比如查看<code>ubuntu:latest</code>镜像的创建过程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@yangjian06 wso2am]# docker history ubuntu:latest</span><br><span class="line">IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT</span><br><span class="line">ccc7a11d65b1        5 weeks ago         /bin/sh -c #(nop)  CMD [&quot;/bin/bash&quot;]            0 B                 </span><br><span class="line">&lt;missing&gt;           5 weeks ago         /bin/sh -c mkdir -p /run/systemd &amp;&amp; echo &apos;doc   7 B                 </span><br><span class="line">&lt;missing&gt;           5 weeks ago         /bin/sh -c sed -i &apos;s/^#\s*\(deb.*universe\)$/   2.759 kB            </span><br><span class="line">&lt;missing&gt;           5 weeks ago         /bin/sh -c rm -rf /var/lib/apt/lists/*          0 B                 </span><br><span class="line">&lt;missing&gt;           5 weeks ago         /bin/sh -c set -xe   &amp;&amp; echo &apos;#!/bin/sh&apos; &gt; /u   745 B               </span><br><span class="line">&lt;missing&gt;           5 weeks ago         /bin/sh -c #(nop) ADD file:39d3593ea220e686d5   120.1 MB</span><br></pre></td></tr></table></figure></p><p>过长的命令被截断了，可以使用<code>--no-trunc</code>选项输出完整命令</p><h2 id="搜索镜像"><a href="#搜索镜像" class="headerlink" title="搜索镜像"></a>搜索镜像</h2><p>使用<code>docker search</code>命令可以搜索镜像库里中共享的镜像，默认搜索官方仓库的镜像。比如我们搜索nginx镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@yangjian06 wso2am]# docker search -s 40 nginx</span><br><span class="line">INDEX       NAME                                               DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED</span><br><span class="line">docker.io   docker.io/nginx                                    Official build of Nginx.                        6865      [OK]       </span><br><span class="line">docker.io   docker.io/jwilder/nginx-proxy                      Automated Nginx reverse proxy for docker c...   1124                 [OK]</span><br><span class="line">docker.io   docker.io/richarvey/nginx-php-fpm                  Container running Nginx + PHP-FPM capable ...   439                  [OK]</span><br><span class="line">docker.io   docker.io/jrcs/letsencrypt-nginx-proxy-companion   LetsEncrypt container to use with nginx as...   223                  [OK]</span><br><span class="line">docker.io   docker.io/kong                                     Open-source Microservice &amp; API Management ...   112       [OK]       </span><br><span class="line">docker.io   docker.io/webdevops/php-nginx                      Nginx with PHP-FPM                              90                   [OK]</span><br><span class="line">docker.io   docker.io/kitematic/hello-world-nginx              A light-weight nginx container that demons...   85</span><br></pre></td></tr></table></figure><p>输出结果将按照星级评级进行排训，<code>-s</code>参数表示星级40以上的nginx镜像，支持的参数还有</p><ul><li><code>--automated=true|false</code> 仅显示自动创建的镜像，默认为否</li><li><code>--no-trunc=true|false</code> 输出信息不截断提示，默认为否<h2 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h2>命令<code>docker rmi</code>可以删除镜像<br>使用标签删除镜像，例如我们删除ubuntu:14镜像</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker rmi ubuntu:14</span><br><span class="line">Untagged: ubuntu:14</span><br></pre></td></tr></table></figure><p>如果该镜像有多个标签的话删除的只是标签并不会删除镜像。如果只有一个标签的话<code>docker rmi</code>命令会彻底删除镜像。  </p><h3 id="使用id删除镜像"><a href="#使用id删除镜像" class="headerlink" title="使用id删除镜像"></a>使用id删除镜像</h3><p>使用命令<code>docker rmi ID</code>命令可以删除镜像</p><blockquote><p>当有该镜像创建的容器存在时，镜像是无法删除的。如果要强行删除的话可以使用<code>docker rmi -f ID</code></p></blockquote><h2 id="创建镜像"><a href="#创建镜像" class="headerlink" title="创建镜像"></a>创建镜像</h2><p>创建镜像的方法主要有三种：基于已有镜像的容器创建，基于本地模板导入，<a href="https://renguangli.com/article/dockerfile.html">基于dockerfile创建镜像</a> </p><h3 id="基于已有镜像的容器创建"><a href="#基于已有镜像的容器创建" class="headerlink" title="基于已有镜像的容器创建"></a>基于已有镜像的容器创建</h3><p>该方法主要是用<code>docker commit</code>命令创建镜像，主要参数为</p><ul><li>-a，–auther=”” 作者信息</li><li>-m, –message=”” 提交信息</li></ul><p>首先我们启动一个nginx镜像,然后进入容器，创建一个test文件，退出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker run -d -p 80:80 nginx</span><br><span class="line">00fb093d0ec2044f6a5d62fe2aa64c487e427456bd53cb6dc8b6462be4e25167</span><br><span class="line">[root@localhost ~]# docker exec -it 00fb093d0 bash </span><br><span class="line">root@00fb093d0ec2:/# touch test</span><br><span class="line">root@00fb093d0ec2:/# exit</span><br><span class="line">[root@localhost ~]#</span><br></pre></td></tr></table></figure><p>这时容器已发生了改变，使用<code>docker commit</code>命令创建一个新的镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker commit -a rgl -m &quot;add a new file&quot;    00fb093d0ec2  test:0.1</span><br><span class="line">sha256:bcaa64525c2bde4e1329f7b28bc2c98b2947f83a5cb0efff6e9d968a85618930</span><br></pre></td></tr></table></figure><p>创建成功的话会返回新镜像的id。</p><h3 id="保存和加载镜像"><a href="#保存和加载镜像" class="headerlink" title="保存和加载镜像"></a>保存和加载镜像</h3><p>如果要存出镜像到本地文件，可以使用<code>docker save</code>命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker save -o nginx.tar nginx:latest</span><br></pre></td></tr></table></figure><p>这样就可以通过复制该镜像文件分享给其他人<br>如果要把镜像文件载入到本地镜像库，使用命令<code>docker load</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker load --input nginx.tar </span><br><span class="line">Loaded image: nginx:latest</span><br></pre></td></tr></table></figure><p>或者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker save nginx:latest &gt; nginx.tar </span><br><span class="line">Loaded image: nginx:latest</span><br><span class="line">[root@localhost ~]# docker load &lt; nginx.tar </span><br><span class="line">Loaded image: nginx:latest</span><br></pre></td></tr></table></figure></p><h3 id="上传镜像"><a href="#上传镜像" class="headerlink" title="上传镜像"></a>上传镜像</h3><p>使用<code>docker push</code>命令上传镜像到仓库，默认上传到Docker官方仓库（需要登录）。例如我们自制的nginx：1.10.0镜像上传，首先我们要添加新的标签user/nginx:1.10.0 ,然后用<code>docker push</code>上传镜像，user改成你的用户名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker push user/nginx:1.10.0</span><br><span class="line">The push refers to a repository [docker.io/user/nginx]</span><br><span class="line">110566462efa: Mounted from library/nginx </span><br><span class="line">305e2b6ef454: Mounted from library/nginx </span><br><span class="line">1.10.0: digest: sha256:d8565c25b654da69bc9b837a0dee713c988f0276e90564aa8fd12ebf4c2ff11e size: 948</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;docker镜像类似于虚拟机镜像，可以将它理解为一个只读的模板。例如，一个镜像可以包含一个基本的操作系统，里面安装了tomcat(或者其它软件)，我们把它称为tomcat镜像。镜像是创建docker容器的基础。通过版本管理和增量的文件系统，docker提供了十分简单的机制来
      
    
    </summary>
    
    
      <category term="docker" scheme="https://renguangli.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker入门之安装</title>
    <link href="https://renguangli.com/article/docker-deploy.html"/>
    <id>https://renguangli.com/article/docker-deploy.html</id>
    <published>2017-09-12T13:49:12.000Z</published>
    <updated>2018-07-12T10:26:34.464Z</updated>
    
    <content type="html"><![CDATA[<p>由于本人系统是centos,所以只演示在centos下的docke安装。其他系统请参考<a href="https://docs.docker.com/install/linux/docker-ce/centos/#set-up-the-repository" target="_blank" rel="noopener">docker官方文档</a></p><h3 id="Centos下安装docker"><a href="#Centos下安装docker" class="headerlink" title="Centos下安装docker"></a>Centos下安装docker</h3><p>系统要求：64为操作系统，内核版本至少为3.10<br>docker目前支持Centos6.5及以上的版本</p><h3 id="yum安装"><a href="#yum安装" class="headerlink" title="yum安装"></a>yum安装</h3><p>执行以下命令添加docker的yum源<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum-config-manager --add-repo    https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure></p><p>对于centos7，Centos-Extras源中已经内置了docker，可以直接通过yum安装<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y docker</span><br></pre></td></tr></table></figure></p><h3 id="启动docker"><a href="#启动docker" class="headerlink" title="启动docker"></a>启动docker</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker.service</span><br></pre></td></tr></table></figure><h3 id="设置docker开启自启动"><a href="#设置docker开启自启动" class="headerlink" title="设置docker开启自启动"></a>设置docker开启自启动</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemclt enable docker.service</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于本人系统是centos,所以只演示在centos下的docke安装。其他系统请参考&lt;a href=&quot;https://docs.docker.com/install/linux/docker-ce/centos/#set-up-the-repository&quot; target
      
    
    </summary>
    
    
      <category term="docker" scheme="https://renguangli.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker入门之简介</title>
    <link href="https://renguangli.com/article/docker-summary.html"/>
    <id>https://renguangli.com/article/docker-summary.html</id>
    <published>2017-09-10T13:52:28.000Z</published>
    <updated>2018-07-12T10:26:34.549Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是docker"><a href="#什么是docker" class="headerlink" title="什么是docker"></a>什么是docker</h2><ul><li>docker是一个开源的应用容器引擎;</li><li>docker是一个开源的软件部署解决方案；</li><li>docker也是轻量级的应用容器框架；</li><li>docker可以打包、发布、运行任何的应用。</li></ul><p>下面的图片比较了 docker 和传统虚拟化方式的不同之处。传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。</p><p><img src="https://rgl-1252211075.cos.ap-beijing.myqcloud.com/docker/docker.png" alt="虚拟机"><br><img src="https://rgl-1252211075.cos.ap-beijing.myqcloud.com/docker/virtualization.png" alt="dcoker"></p><h2 id="为什么要用docker"><a href="#为什么要用docker" class="headerlink" title="为什么要用docker"></a>为什么要用docker</h2><p>作为一种新兴的虚拟化方式，docker 跟传统的虚拟化方式相比具有众多的优势。</p><h3 id="更高效的利用系统资源"><a href="#更高效的利用系统资源" class="headerlink" title="更高效的利用系统资源"></a>更高效的利用系统资源</h3><p>由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，docker 对系统资源的利用率更高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。</p><h3 id="更快速的启动时间"><a href="#更快速的启动时间" class="headerlink" title="更快速的启动时间"></a>更快速的启动时间</h3><p>传统的虚拟机技术启动应用服务往往需要数分钟，而 docker 容器应用，由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。</p><h3 id="一致的运行环境"><a href="#一致的运行环境" class="headerlink" title="一致的运行环境"></a>一致的运行环境</h3><p>开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环境不一致，导致有些 bug 并未在开发过程中被发现。而 docker 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 「这段代码在我机器上没问题啊」 这类问题。</p><h3 id="持续交付和部署"><a href="#持续交付和部署" class="headerlink" title="持续交付和部署"></a>持续交付和部署</h3><p>对开发和运维（DevOps）人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。<br>使用 docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过 dockerfile 来进行镜像构建，并结合 持续集成(Continuous Integration) 系统进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合 持续部署(Continuous Delivery/Deployment) 系统进行自动部署。<br>而且使用 dockerfile 使镜像构建透明化，不仅仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需条件，帮助更好的生产环境中部署该镜像。</p><h3 id="更轻松的迁移"><a href="#更轻松的迁移" class="headerlink" title="更轻松的迁移"></a>更轻松的迁移</h3><p>由于 docker 确保了执行环境的一致性，使得应用的迁移更加容易。docker 可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。</p><h3 id="更轻松的维护和扩展"><a href="#更轻松的维护和扩展" class="headerlink" title="更轻松的维护和扩展"></a>更轻松的维护和扩展</h3><p>docker 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。此外，docker 团队同各个开源项目团队一起维护了一大批高质量的官方镜像，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本。</p><h3 id="对比传统虚拟机总结"><a href="#对比传统虚拟机总结" class="headerlink" title="对比传统虚拟机总结"></a>对比传统虚拟机总结</h3><table><thead><tr><th style="text-align:center">特性</th><th style="text-align:center">容器</th><th style="text-align:center">虚拟机</th></tr></thead><tbody><tr><td style="text-align:center">启动</td><td style="text-align:center">秒级</td><td style="text-align:center">分钟级</td></tr><tr><td style="text-align:center">硬盘使用</td><td style="text-align:center">一般为 MB</td><td style="text-align:center">一般为 GB</td></tr><tr><td style="text-align:center">性能</td><td style="text-align:center">接近原生</td><td style="text-align:center">弱于</td></tr><tr><td style="text-align:center">系统支持量</td><td style="text-align:center">单机支持上千个容器</td><td style="text-align:center">一般几十个</td></tr></tbody></table><blockquote><p><a href="https://baike.baidu.com/item/Docker/13344470?fr=aladdin" target="_blank" rel="noopener">百度百科</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是docker&quot;&gt;&lt;a href=&quot;#什么是docker&quot; class=&quot;headerlink&quot; title=&quot;什么是docker&quot;&gt;&lt;/a&gt;什么是docker&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;docker是一个开源的应用容器引擎;&lt;/li&gt;
&lt;li&gt;docker是
      
    
    </summary>
    
    
      <category term="docker" scheme="https://renguangli.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>hexo之博客搭建</title>
    <link href="https://renguangli.com/article/hexo.html"/>
    <id>https://renguangli.com/article/hexo.html</id>
    <published>2016-10-07T10:58:25.000Z</published>
    <updated>2018-07-12T09:36:16.095Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是-Hexo？"><a href="#什么是-Hexo？" class="headerlink" title="什么是 Hexo？"></a>什么是 Hexo？</h3><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 <a href="https://daringfireball.net/projects/markdown/" target="_blank" rel="noopener">Markdown</a>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页，详情请看<a href="https://hexo.io/" target="_blank" rel="noopener">hexo官网</a>。在使用之前电脑必须安装<a href="https://nodejs.org/" target="_blank" rel="noopener">nodejs</a>和<a href="https://git-scm.com/" target="_blank" rel="noopener">git</a></p><h3 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br><span class="line">$ hexo init blog</span><br><span class="line">$ <span class="built_in">cd</span> blog</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure><h3 id="创建新文章"><a href="#创建新文章" class="headerlink" title="创建新文章"></a>创建新文章</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"文章标题"</span></span><br></pre></td></tr></table></figure><p>如果文章标题之间有空格要用引号引起来</p><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>打开浏览器，在地址栏输入 localhost:4000就会出现如下界面</p><p><img src="/images/hexo.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;什么是-Hexo？&quot;&gt;&lt;a href=&quot;#什么是-Hexo？&quot; class=&quot;headerlink&quot; title=&quot;什么是 Hexo？&quot;&gt;&lt;/a&gt;什么是 Hexo？&lt;/h3&gt;&lt;p&gt;Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 &lt;a href=&quot;htt
      
    
    </summary>
    
      <category term="hexo" scheme="https://renguangli.com/categories/hexo/"/>
    
    
      <category term="hexo" scheme="https://renguangli.com/tags/hexo/"/>
    
  </entry>
  
</feed>
