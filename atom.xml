<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dali`s Blogs</title>
  
  <subtitle>大力的技术博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://renguangli.com/"/>
  <updated>2018-06-11T09:47:45.051Z</updated>
  <id>https://renguangli.com/</id>
  
  <author>
    <name>大力</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HashMap中的key</title>
    <link href="https://renguangli.com/article/map-key.html"/>
    <id>https://renguangli.com/article/map-key.html</id>
    <published>2018-06-04T09:48:20.000Z</published>
    <updated>2018-06-11T09:47:45.051Z</updated>
    
    <content type="html"><![CDATA[<p>HashMap是一种用哈希值来存储和查找键值对（key-value pair，也称作entry）的一种数据结构。</p><h3 id="不可变类作为HashMap的key带来的影响"><a href="#不可变类作为HashMap的key带来的影响" class="headerlink" title="不可变类作为HashMap的key带来的影响"></a>不可变类作为HashMap的key带来的影响</h3><p>我们都知道HashMap的key必须是不可变对象，例如String，Integer等，那么如果用可变对象作为HashMap的key有什么影响呢？下面看一段代码<br>定义:<br><a id="more"></a><br><strong>什么是不可变类？</strong><br>不可变类的意思是创建该类的实例后，该实例的属性是不可改变的；所以不可变类并不是指该类是被final修饰的，而是指该类的属性是被final修饰的自定义不可变类遵守如下原则：</p><ul><li>使用private和final修饰符来修饰该类的属性。</li><li>提供带参数的构造器，用于根据传入的参数来初始化属性。</li><li>仅为该类属性提供getter方法，不要提供setter方法。</li><li>如果有必要，重写hashCode和equals方法，同时应保证两个用equals方法判断为相等的对象，其hashCode也应相等</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义User类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getter/setter ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;HashMap是一种用哈希值来存储和查找键值对（key-value pair，也称作entry）的一种数据结构。&lt;/p&gt;
&lt;h3 id=&quot;不可变类作为HashMap的key带来的影响&quot;&gt;&lt;a href=&quot;#不可变类作为HashMap的key带来的影响&quot; class=&quot;headerlink&quot; title=&quot;不可变类作为HashMap的key带来的影响&quot;&gt;&lt;/a&gt;不可变类作为HashMap的key带来的影响&lt;/h3&gt;&lt;p&gt;我们都知道HashMap的key必须是不可变对象，例如String，Integer等，那么如果用可变对象作为HashMap的key有什么影响呢？下面看一段代码&lt;br&gt;定义:&lt;br&gt;
    
    </summary>
    
    
      <category term="HashMap" scheme="https://renguangli.com/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>IT技术电子书下载</title>
    <link href="https://renguangli.com/article/book-download.html"/>
    <id>https://renguangli.com/article/book-download.html</id>
    <published>2018-06-01T12:55:48.000Z</published>
    <updated>2018-06-04T09:45:30.011Z</updated>
    
    <content type="html"><![CDATA[<h3 id="电子书下载"><a href="#电子书下载" class="headerlink" title="电子书下载"></a>电子书下载</h3><p>JSR133规范 <a href="/download/JSR133.pdf">点击下载</a><br>JAVA虚拟机规范 <a href="/download/memory_model-1_0-pfd-spec.pdf">点击下载</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;电子书下载&quot;&gt;&lt;a href=&quot;#电子书下载&quot; class=&quot;headerlink&quot; title=&quot;电子书下载&quot;&gt;&lt;/a&gt;电子书下载&lt;/h3&gt;&lt;p&gt;JSR133规范 &lt;a href=&quot;/download/JSR133.pdf&quot;&gt;点击下载&lt;/a&gt;&lt;br&gt;JAVA虚拟
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>常用Map之间的比较</title>
    <link href="https://renguangli.com/article/01b9def0-63e1-11e8-9c6e-67f722e0ee44.html"/>
    <id>https://renguangli.com/article/01b9def0-63e1-11e8-9c6e-67f722e0ee44.html</id>
    <published>2018-05-30T08:11:08.000Z</published>
    <updated>2018-05-30T08:11:08.261Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>有关Map的面试题(持续更新中...)</title>
    <link href="https://renguangli.com/article/map.html"/>
    <id>https://renguangli.com/article/map.html</id>
    <published>2018-05-30T03:35:35.000Z</published>
    <updated>2018-06-11T09:47:14.154Z</updated>
    
    <content type="html"><![CDATA[<p>Map是我们常用的集合类，在面试中经常被问到，所以我们要彻底掌握它。以下是我整理的有关Map的面试题以及一些自己的理解，希望可以帮助到大家。<br><a id="more"></a></p><h3 id="1、所有的类都可以作为Map中的key吗？有什么需要注意的问题？"><a href="#1、所有的类都可以作为Map中的key吗？有什么需要注意的问题？" class="headerlink" title="1、所有的类都可以作为Map中的key吗？有什么需要注意的问题？"></a>1、所有的类都可以作为Map中的key吗？有什么需要注意的问题？</h3><p>Map中的key必须是不可变类，如果非要用可变类作为key，则必须重写equals和hashCode方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Map是我们常用的集合类，在面试中经常被问到，所以我们要彻底掌握它。以下是我整理的有关Map的面试题以及一些自己的理解，希望可以帮助到大家。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>了解JAVA虚拟机-运行时数据区域</title>
    <link href="https://renguangli.com/article/jvm-runtime-area.html"/>
    <id>https://renguangli.com/article/jvm-runtime-area.html</id>
    <published>2018-05-30T03:02:15.000Z</published>
    <updated>2018-06-11T09:47:22.049Z</updated>
    
    <content type="html"><![CDATA[<p>JVM虚拟机把它所管理的内存划分为若干个用途不同的内存区域，包括程序计数器、JAVA虚拟机栈、本地方法栈、堆、方法区、运行时常量池、直接内存。这些区域中方法区和堆是线程共享的，其他是线程私有的。<br><a id="more"></a></p><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>程序计数器可以看作当前线程所执行字节码的行号指示器，字节码解释器通过改变计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都要依赖这个计数器来完成。</p><ul><li>如果线程执行的是java方法则计数器记录的是正在执行的字节码指令的地址</li><li>如果线程线性的是native方法则计数器的值为空。</li></ul><p>程序计数器是一块较小的内存区域，而且是JVM规范中唯一一处没有规定OutOfMemoryError异常的内存区域</p><h2 id="JAVA虚拟机栈"><a href="#JAVA虚拟机栈" class="headerlink" title="JAVA虚拟机栈"></a>JAVA虚拟机栈</h2><p>JAVA虚拟机栈描述的是JAVA方法执行的内存模型。<br>每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。<br>每一个方法从执行到结束的过程都对应一个栈帧从入栈到出栈的过程</p><p>人们经常JAVA内存分为堆内存和栈内存，其中栈指的就是JAVA虚拟机栈，或者说是JAVA虚拟机栈中的局部变量表。局部变量表保存了编译器可知的各种基本数据类型（byte、short、int、long、float、double，boolean、char)、对象引用(reference)、返回地址(returnAddress).其中64位长度的long和double会占用2个局部变量空间(Slot),其余数据类型占用1个局部变量表空间。局部变量表的内存大小在编译器就确定好了，在方法运行期间不会改变其内存大小。</p><p>在JAVA虚拟机规范中对JAVA虚拟机栈规定了两种异常</p><ul><li>如果线程请求的栈深度大于JAVA虚拟机栈的深度，就会抛出StackOverFlowError异常</li><li>如果JAVA虚拟机栈可以动态扩展且动态扩展是无法申请到足够的内存就会抛出OutOfMemoryError异常</li></ul><h2 id="JAVA堆"><a href="#JAVA堆" class="headerlink" title="JAVA堆"></a>JAVA堆</h2><p>JAVA堆是所有线程共享的一块内存，几乎所有的对象实例都在这里分配。JAVA堆分为老年代和新生代，再吸一点有Eden空间，Frovivor，To Survivor空间等。<br>如果在堆中无法完成对象实例的内存分配，并且堆无法在扩展时，JVM将会发生OutOfMemoryError错误。</p><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>方法区跟JAVA堆一样是所有线程共享的一块内存区域，它存储了已被虚拟机加载的类信息、常量、静态变量、即时编译器编译的代码等。他还有两个别名非堆和永久代。当方法区无法完成内存分配是将抛出OutOfMemoryError错误。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JVM虚拟机把它所管理的内存划分为若干个用途不同的内存区域，包括程序计数器、JAVA虚拟机栈、本地方法栈、堆、方法区、运行时常量池、直接内存。这些区域中方法区和堆是线程共享的，其他是线程私有的。&lt;br&gt;
    
    </summary>
    
    
      <category term="JVM" scheme="https://renguangli.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>每天学点儿linux--centos配置nginx-yum源</title>
    <link href="https://renguangli.com/article/37e899f0-5ca5-11e8-9013-eb256eb833fe.html"/>
    <id>https://renguangli.com/article/37e899f0-5ca5-11e8-9013-eb256eb833fe.html</id>
    <published>2018-05-21T03:15:31.000Z</published>
    <updated>2018-06-11T09:47:03.496Z</updated>
    
    <content type="html"><![CDATA[<p>创建/etc/yum.repos.d/nginx.repo文件，并添加一下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[nginx]</span><br><span class="line">name=nginx repo</span><br><span class="line">baseurl=http://nginx.org/packages/OS/OSRELEASE/$basearch/</span><br><span class="line">gpgcheck=0</span><br><span class="line">enabled=1</span><br></pre></td></tr></table></figure><a id="more"></a><p>将OS替换为“rhel” 或者 “centos”， “OSRELEASE”替换为7或6,取决与你的centos系统版本，6代表6.X版本，7代表7.X版本。替换完之后保存文件，然后就可以使用yum安装nignx了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install nginx</span><br></pre></td></tr></table></figure><p>参考资料<br><a href="http://nginx.org/en/linux_packages.html" target="_blank" rel="noopener">http://nginx.org/en/linux_packages.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;创建/etc/yum.repos.d/nginx.repo文件，并添加一下内容&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[nginx]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;name=nginx repo&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;baseurl=http://nginx.org/packages/OS/OSRELEASE/$basearch/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;gpgcheck=0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;enabled=1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="nginx" scheme="https://renguangli.com/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>每天学点儿linux--centos7开放端口号</title>
    <link href="https://renguangli.com/article/centos-open-port.html"/>
    <id>https://renguangli.com/article/centos-open-port.html</id>
    <published>2018-05-15T11:44:20.000Z</published>
    <updated>2018-06-11T09:46:22.952Z</updated>
    
    <content type="html"><![CDATA[<p>开放80端口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=80/tcp --permanent</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>命令含义：  </p><ul><li>–zone #作用域  </li><li>–add-port=80/tcp  #添加端口，格式为：端口/通讯协议  </li><li>–permanent  #永久生效，没有此参数重启后失效  </li></ul><p>关闭80端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd  --zone=public --remove-port=80/tcp --permanent</span><br></pre></td></tr></table></figure><p>查看防火墙状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status firewalld.service</span><br></pre></td></tr></table></figure><p>启动|关闭|重新启动  防火墙</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl [start|stop|restart] firewalld.service</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;开放80端口&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;firewall-cmd --zone=public --add-port=80/tcp --permanent&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="每天学点儿linux" scheme="https://renguangli.com/tags/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E7%82%B9%E5%84%BFlinux/"/>
    
  </entry>
  
  <entry>
    <title>每天学点儿linux--vi编辑器的使用</title>
    <link href="https://renguangli.com/article/linux-vi.html"/>
    <id>https://renguangli.com/article/linux-vi.html</id>
    <published>2018-05-15T11:42:19.000Z</published>
    <updated>2018-06-11T09:46:51.936Z</updated>
    
    <content type="html"><![CDATA[<p>vi编辑器是Linux系统下标准的编辑器，一般linux都没有桌面环境，平常修改一些配置文件，编写脚本对于vi编辑器来说都很方便，所以我们有必要学会并熟练使用它。<br>vi编辑器可以分为三种状态，分别是命令模式、插入模式和底行模式  </p><ul><li>命令行模式：控制屏幕光标的移动、字符、字或行的删除，移动复制某区段及进入插入模式下，或者到底行模式。   </li><li>插入模式：只有在插入模式下，才可以做文字输入，按「ESC」键可回到命令行模式。</li><li>底行模式：将文件保存或退出vi，也可以设置编辑环境，如寻找字符串、列出行号……等。 <a id="more"></a></li></ul><p>下面列举一些常用命令和技巧</p><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>我们如何进入vi编辑器呢？<br>输入<code>vi fileName</code>命令进入vi编辑器，这时处于命令行模式。<br>在命令模式下按下<code>i</code>字母就会进入插入模式，这时就可以对对文件进行编辑了。<br>那我们如何退出vi编辑器呢？<br>在命令行模式下，按一下 <code>:</code>冒号键进入底行模式</p><ul><li><code>:w</code>保存但不退出。</li><li><code>:w fileName</code>文件另存为filename。</li><li><code>:wq</code>保存并退出。</li><li><code>:q</code>退出但不保存。<br>在末尾加入<code>！</code>表示强制执行，例如<code>:q!</code>表示强制退出但不保存。</li></ul><h2 id="命令行模式功能键"><a href="#命令行模式功能键" class="headerlink" title="命令行模式功能键"></a>命令行模式功能键</h2><h3 id="进入插入模式的几种方法。"><a href="#进入插入模式的几种方法。" class="headerlink" title="进入插入模式的几种方法。"></a>进入插入模式的几种方法。</h3><ul><li>按<code>i</code>进入插入模式后，光标当前位置开始输入文件；</li><li>按大写<code>I</code>进入插入模式后，光标所在行开始位置开始输入文件</li><li>按<code>a</code>进入插入模式后，光标所在位置的下一个位置开始输入文字； </li><li>按<code>A</code>进入插入模式后，光标所在行末尾开始输入文字； </li><li>按<code>o</code>进入插入模式后，在当前行下一行插入新的一行，从行首开始输入文字。 </li><li>按<code>O</code>进入插入模式后，在当前行上一行是插入新的一行，从行首开始输入文字。</li></ul><h3 id="移动光标"><a href="#移动光标" class="headerlink" title="移动光标"></a>移动光标</h3><p>vi可以直接用键盘上的光标来上下左右移动，但正规的vi是用小写英文字母<code>hjkl</code>，分别控制光标左、下、上、右移一格。<br>其他移动光标的功能键</p><ul><li><code>ctrl + b</code>屏幕往“后”移动一页。 </li><li><code>ctrl + f</code>屏幕往“前”移动一页。 </li><li><code>ctrl + u</code>屏幕往“后”移动半页</li><li><code>ctrl + d</code>屏幕往“前”移动半页。</li><li><code>home</code>,<code>^</code>,<code>0</code>移到行首。</li><li><code>end</code>,<code>\$</code>移到行尾</li><li><code>gg</code>移到文件开头。</li><li><code>G</code>移到文件最后。</li><li><code>w</code>光标跳到下个字的开头 </li><li><code>e</code>光标跳到下个字的字尾 </li><li><code>b</code>光标回到上个字的开头 </li><li><code>#l</code>光标移到该行的第#个位置，如：5l,56l。 </li></ul><h3 id="删除文字"><a href="#删除文字" class="headerlink" title="删除文字"></a>删除文字</h3><ul><li><code>x</code>每按一次，删除光标所在位置的“后面”一个字符。 </li><li><code>#x</code>：例如，「6x」表示删除光标所在位置的“后面”6个字符。 </li><li><code>X</code>大写的X，每按一次，删除光标所在位置的“前面”一个字符。 </li><li><code>#X</code>例如，「20X」表示删除光标所在位置的“前面”20个字符。 </li><li><code>dd</code>删除光标所在行。 </li><li><code>#dd</code>从光标所在行开始删除#行 </li></ul><h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><ul><li><code>yw</code>将光标所在之处到字尾的字符复制到缓冲区中。 </li><li><code>#wy</code>复制#个字到缓冲区 </li><li><code>yy</code>复制光标所在行到缓冲区。 </li><li><code>#yy</code>例如，「6yy」表示拷贝从光标所在的该行“往下数”6行文字。 </li><li><code>p</code>将缓冲区内的字符贴到光标所在位置。注意：所有与“y”有关的复制命令都必须与“p”配合才能完成复制与粘贴功能。</li></ul><h3 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h3><ul><li><code>r</code>替换光标所在处的字符。 </li><li><code>R</code>替换光标所到之处的字符，直到按下「ESC」键为止。 </li></ul><h3 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h3><ul><li><code>u</code>如果您误执行一个命令，可以马上按下<code>u</code>，回到上一个操作。按多次“u”可以执行多次回复。 </li></ul><h3 id="更改"><a href="#更改" class="headerlink" title="更改"></a>更改</h3><ul><li><code>cw</code>更改光标所在处的字到字尾处 </li><li><code>c#w</code>例如,<code>c3w</code>表示更改3个字 </li></ul><h3 id="跳至指定的行"><a href="#跳至指定的行" class="headerlink" title="跳至指定的行"></a>跳至指定的行</h3><ul><li><code>ctrl + g</code>列出光标所在行的行号。 </li><li><code>#G</code>例如，<code>10G</code>，表示移动光标至文章的第15行行首。 </li></ul><h2 id="底行模式下命令简介"><a href="#底行模式下命令简介" class="headerlink" title="底行模式下命令简介"></a>底行模式下命令简介</h2><p>　　在使用底行模式之前，请记住先按「ESC」键确定您已经处于命令行模式下后，再按<code>:</code>冒号即可进入底行模式。 </p><h3 id="列出行号"><a href="#列出行号" class="headerlink" title="列出行号"></a>列出行号</h3><ul><li><code>set nu</code>输入<code>set nu</code>后，会在文件中的每一行前面列出行号。 </li></ul><h3 id="跳到文件中的某一行"><a href="#跳到文件中的某一行" class="headerlink" title="跳到文件中的某一行"></a>跳到文件中的某一行</h3><ul><li><code>#</code>号表示一个数字，在冒号后输入一个数字，再按回车键就会跳到该行了，如输入数字15，再回车，就会跳到文章的第15行。 </li></ul><h3 id="查找字符"><a href="#查找字符" class="headerlink" title="查找字符"></a>查找字符</h3><ul><li><code>/关键字</code>先按<code>/</code>键，再输入您想寻找的字符，如果第一次找的关键字不是您想要的，可以一直按<code>n</code>会往后寻找到您要的关键字为止。 </li><li><code>?关键字</code>先按<code>?</code>键，再输入您想寻找的字符，如果第一次找的关键字不是您想要的，可以一直按<code>n</code>会往前寻找到您要的关键字为止。 </li></ul><h3 id="保存文件"><a href="#保存文件" class="headerlink" title="保存文件"></a>保存文件</h3><ul><li><code>w</code>在冒号输入字母<code>w</code>就可以将文件保存起来。 </li></ul><h3 id="离开vi"><a href="#离开vi" class="headerlink" title="离开vi"></a>离开vi</h3><ul><li><code>q</code>按「q」就是退出，如果无法离开vi，可以在<code>q</code>跟一个<code>!</code>强制离开vi。 </li><li><code>qw</code>一般建议离开时，搭配<code>w</code>一起使用，这样在退出的时候还可以保存文件。 </li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;vi编辑器是Linux系统下标准的编辑器，一般linux都没有桌面环境，平常修改一些配置文件，编写脚本对于vi编辑器来说都很方便，所以我们有必要学会并熟练使用它。&lt;br&gt;vi编辑器可以分为三种状态，分别是命令模式、插入模式和底行模式  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;命令行模式：控制屏幕光标的移动、字符、字或行的删除，移动复制某区段及进入插入模式下，或者到底行模式。   &lt;/li&gt;
&lt;li&gt;插入模式：只有在插入模式下，才可以做文字输入，按「ESC」键可回到命令行模式。&lt;/li&gt;
&lt;li&gt;底行模式：将文件保存或退出vi，也可以设置编辑环境，如寻找字符串、列出行号……等。
    
    </summary>
    
    
      <category term="每天学点儿linux" scheme="https://renguangli.com/tags/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E7%82%B9%E5%84%BFlinux/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之代理模式</title>
    <link href="https://renguangli.com/article/java-proxy.html"/>
    <id>https://renguangli.com/article/java-proxy.html</id>
    <published>2017-11-05T13:17:32.000Z</published>
    <updated>2018-06-11T09:46:42.060Z</updated>
    
    <content type="html"><![CDATA[<p>什么是代理模式呢？我很忙，忙的没空理你，那你要找我呢就先找我的代理人吧，那代理人总要知道<br>被代理人能做哪些事情不能做哪些事情吧，那就是两个人具备同一个接口，代理人虽然不能干活，但是被<br>代理的人能干活呀<br><a id="more"></a></p><h2 id="定义一个User接口"><a href="#定义一个User接口" class="headerlink" title="定义一个User接口"></a>定义一个User接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * User</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> renguangli 2017/10/25 16:30</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">login</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">logout</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="在定义一个RealUser类实现User接口"><a href="#在定义一个RealUser类实现User接口" class="headerlink" title="在定义一个RealUser类实现User接口"></a>在定义一个RealUser类实现User接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * RealUser</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> renguangli 2017/10/25 16:41</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealUser</span> <span class="keyword">implements</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="在定义一个User代理类"><a href="#在定义一个User代理类" class="headerlink" title="在定义一个User代理类"></a>在定义一个User代理类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * UserProxy</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> renguangli 2017/10/25 16:42</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserProxy</span> <span class="keyword">implements</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line">    <span class="comment">//默认代理RealUser</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserProxy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.user = <span class="keyword">new</span> RealUser();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserProxy</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.user = user;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        user.login();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        user.logout();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试一下"><a href="#测试一下" class="headerlink" title="测试一下"></a>测试一下</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ProxyTest</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> renguangli 2017/10/25 16:45</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        UserProxy userProxy = <span class="keyword">new</span> UserProxy();</span><br><span class="line">        userProxy.login();</span><br><span class="line">        userProxy.logout();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出<br>com.renguangli.pattern23.proxy.RealUser<br>com.renguangli.pattern23.proxy.RealUser<br>看起来像是UserProxy在登录退出，实际上是RealUser</p><h2 id="在来一个FakeUser类实现User接口"><a href="#在来一个FakeUser类实现User接口" class="headerlink" title="在来一个FakeUser类实现User接口"></a>在来一个FakeUser类实现User接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * FakeUser</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> renguangli 2017/10/25 16:44</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FakeUser</span> <span class="keyword">implements</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="再测一下"><a href="#再测一下" class="headerlink" title="再测一下"></a>再测一下</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ProxyTest</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> renguangli 2017/10/25 16:45</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FakeUser fakeUser = <span class="keyword">new</span> FakeUser();</span><br><span class="line">        UserProxy userProxy = <span class="keyword">new</span> UserProxy(fakeUser);</span><br><span class="line">        userProxy.login();</span><br><span class="line">        userProxy.logout();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出<br>com.renguangli.pattern23.proxy.FakeUser<br>com.renguangli.pattern23.proxy.FakeUser</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>代理模式主要使用了Java的多态，干活的是被代理类，代理类主要是接活，那怎么知道被代理类能不能干呢，就是代理类和被代理类实现同一个接口</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;什么是代理模式呢？我很忙，忙的没空理你，那你要找我呢就先找我的代理人吧，那代理人总要知道&lt;br&gt;被代理人能做哪些事情不能做哪些事情吧，那就是两个人具备同一个接口，代理人虽然不能干活，但是被&lt;br&gt;代理的人能干活呀&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="https://renguangli.com/categories/java/"/>
    
    
      <category term="设计模式" scheme="https://renguangli.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>docker入门之Dockerfile</title>
    <link href="https://renguangli.com/article/dockerfile.html"/>
    <id>https://renguangli.com/article/dockerfile.html</id>
    <published>2017-10-31T10:27:13.000Z</published>
    <updated>2018-06-11T09:48:17.379Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Dockerfile指令简单介绍"><a href="#Dockerfile指令简单介绍" class="headerlink" title="Dockerfile指令简单介绍"></a>Dockerfile指令简单介绍</h2><h4 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h4><p><code>FROM</code>指定基础镜像，若镜像不存在Docker会从docker hub中 来查找该镜像。<code>FROM</code>命令必须是Dockerfile的首个命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FROM centos:7.2.1511</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="MAINTAINER"><a href="#MAINTAINER" class="headerlink" title="MAINTAINER"></a>MAINTAINER</h4><p>维护者信息,一般用来指定作者,紧跟<code>FROM</code>命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MAINTAINER Ren Guangli &lt;renguangli@bonc.com.cn&gt;</span><br></pre></td></tr></table></figure><h4 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h4><p>Dockerfile中的<code>COPY</code>指令和<code>ADD</code>指令都可以将主机上的资源复制或加入到容器镜像中，都是在构建镜像的过程中完成的。<code>ADD</code>指令不仅能够将构建命令所在的主机本地的文件或目录，而且能够将远程URL所对应的文件或目录，作为资源复制到镜像文件系统。如果源文件是identity, gzip, bzip2，xz，tar.gz，tgz等类型的压缩文件，会添加tar -x命令，自动解压</p><blockquote><p>对于从远程URL获取资源的情况，由于ADD指令不支持认证，如果从远程获取资源需要认证，则只能使用RUN wget或RUN curl替代。<br>另外，如果源路径的资源发生变化，则该ADD指令将使Docker Cache失效，Dockerfile中后续的所有指令都不能使用缓存。因此尽量将ADD指令放在Dockerfile的后面。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># exec格式用法</span><br><span class="line">ADD [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;]</span><br><span class="line">ADD [&quot;hello.sh&quot;,&quot;docker.sh&quot;,&quot;/mnt&quot;]</span><br></pre></td></tr></table></figure><p>适合路径中带有空格的情况<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># shell格式用法</span><br><span class="line">ADD &lt;src&gt;... &lt;dest&gt;</span><br><span class="line">ADD hello.sh docker.sh /mnt</span><br></pre></td></tr></table></figure></p><p>注意事项</p><ul><li>源路径可以有多个</li><li>源路径是相对于执行build的相对路径</li><li>源路径如果是本地路径，必须是build上下文中的路径</li><li>源路径如果是一个目录，则该目录下的所有内容都将被加入到容器，但是该目录本身不会</li><li>目标路径必须是绝对路径，或相对于WORKDIR的相对路径</li><li>目标路径如果不存在，则会创建相应的完整路径</li><li>路径中可以使用通配符</li></ul><h4 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h4><p>和<code>ADD</code>指令类似，只是不能从远端获取资源和自动解压压缩文件</p><h4 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h4><p>配置环境变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENV &lt;key&gt; &lt;value&gt;</span><br><span class="line">ENV &lt;key&gt;=&lt;value&gt; ...</span><br></pre></td></tr></table></figure><p>第二种格式可以设置多个键值对，推荐在一条<code>ENV</code>指令中设置多个键值对，因为这样产生一个缓存层。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENV JAVA_HOME=/mnt/jdk1.7 PATH=$JAVA_HOME/bin:$PATH CLASSPATH=.:$JAVA_HOME/lib</span><br></pre></td></tr></table></figure><h4 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPOSE &lt;port&gt; [&lt;port&gt;...]</span><br></pre></td></tr></table></figure><p>指定于外界交互的端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPOSE 8080 443</span><br></pre></td></tr></table></figure><p>在容器启动时用-p传递参数，例如<code>docker run -d -p 8088:8080 -p 8089:443 tomcat:7.0.81</code>将容器内的8080绑定到本机的8088端口,443绑定到本机的8089端口</p><h4 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USER root</span><br></pre></td></tr></table></figure><p>指定运行容器时的用户名或 UID，后续的RUN、CMD、ENTRYPOINT也会使用指定用户。</p><h4 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WORKDIR /path/to/workdir</span><br></pre></td></tr></table></figure><p>为后续的RUN、CMD、ENTRYPOINT指令配置工作目录。可以使用多个WORKDIR指令，后续命令如果参数是相对路径，则会基于之前命令指定的路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">WORKDIR /a</span><br><span class="line">WORKDIR b</span><br><span class="line">WORKDIR c</span><br><span class="line">RUN pwd</span><br></pre></td></tr></table></figure><p>最终路径是/a/b/c。\<br>WORKDIR指令可以在ENV设置变量之后调用环境变量:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENV DIRPATH /path</span><br><span class="line">WORKDIR $DIRPATH/$DIRNAME</span><br></pre></td></tr></table></figure><p>最终路径则为 <code>/path/$DIRNAME</code>。</p><h3 id="参考连接"><a href="#参考连接" class="headerlink" title="参考连接"></a>参考连接</h3><p><a href="http://www.docker.org.cn/dockerppt/114.html" target="_blank" rel="noopener">http://www.docker.org.cn/dockerppt/114.html</a> \<br><a href="http://www.cnblogs.com/sorex/p/6481407.html" target="_blank" rel="noopener">http://www.cnblogs.com/sorex/p/6481407.html</a> \<br><a href="http://blog.csdn.net/taiyangdao/article/details/73222601" target="_blank" rel="noopener">http://blog.csdn.net/taiyangdao/article/details/73222601</a> </p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Dockerfile指令简单介绍&quot;&gt;&lt;a href=&quot;#Dockerfile指令简单介绍&quot; class=&quot;headerlink&quot; title=&quot;Dockerfile指令简单介绍&quot;&gt;&lt;/a&gt;Dockerfile指令简单介绍&lt;/h2&gt;&lt;h4 id=&quot;FROM&quot;&gt;&lt;a href=&quot;#FROM&quot; class=&quot;headerlink&quot; title=&quot;FROM&quot;&gt;&lt;/a&gt;FROM&lt;/h4&gt;&lt;p&gt;&lt;code&gt;FROM&lt;/code&gt;指定基础镜像，若镜像不存在Docker会从docker hub中 来查找该镜像。&lt;code&gt;FROM&lt;/code&gt;命令必须是Dockerfile的首个命令。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;FROM centos:7.2.1511&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="docker" scheme="https://renguangli.com/categories/docker/"/>
    
    
      <category term="docker" scheme="https://renguangli.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker入门之容器</title>
    <link href="https://renguangli.com/article/docker-container.html"/>
    <id>https://renguangli.com/article/docker-container.html</id>
    <published>2017-09-15T13:47:24.000Z</published>
    <updated>2018-06-11T09:48:06.349Z</updated>
    
    <content type="html"><![CDATA[<p>容器是Docker的另一个核心概念，简单来说容器就是镜像的一个运行示例。<br><a id="more"></a></p><h3 id="查看容器"><a href="#查看容器" class="headerlink" title="查看容器"></a>查看容器</h3><p>使用<code>docker ps</code>命令查看运行着的容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker ps</span><br><span class="line">CONTAINER ID        IMAGE                  COMMAND                  CREATED             STATUS              PORTS                NAMES</span><br><span class="line">229929eb660f        renguangli/nginx:1.0   &quot;nginx -g &apos;daemon off&quot;   17 hours ago        Up 3 seconds        0.0.0.0:80-&gt;80/tcp   nginx</span><br></pre></td></tr></table></figure><p>使用<code>docker ps -a</code>命令查看所有的容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE                  COMMAND                  CREATED             STATUS              PORTS                NAMES</span><br><span class="line">229929eb660f        renguangli/nginx:1.0   &quot;nginx -g &apos;daemon off&quot;   17 hours ago        Up 3 seconds        0.0.0.0:80-&gt;80/tcp   nginx</span><br><span class="line">3ceb621f4aa9        jenkins             &quot;/bin/tini -- /usr/lo&quot;   About an hour ago   Exited (137) 48 seconds ago                            elated_davinci</span><br></pre></td></tr></table></figure><p>使用<code>docker create image:tag name</code>命令创建一个容器并给容器一个name，例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker create nginx:latest nginx</span><br><span class="line">fd47cedfcce5cd2879ef65b342b1cd4130cbcc081cec532ff7af1744ad589116</span><br></pre></td></tr></table></figure><p>如果不加name的话随机分配一个名字</p><h3 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h3><p>使用<code>docker start 容器名称或容器ID</code>来启动一个容器，例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker ps -a</span><br><span class="line">229929eb660f        renguangli/nginx:1.0   &quot;nginx -g &apos;daemon off&quot;   17 hours ago        Exited (0) 8 seconds ago                        nginx</span><br><span class="line">[root@localhost ~]# docker start nginx 或者 docker start 229929eb660f</span><br></pre></td></tr></table></figure><h3 id="新建并启动容器"><a href="#新建并启动容器" class="headerlink" title="新建并启动容器"></a>新建并启动容器</h3><p>创建容器后可以用<code>docker start</code>命令启动容器，也可以用<code>docker run</code>命令直接新建并启动容器，<code>docker run</code>相当于先执行<code>docker create</code>命令在执行<code>docker start</code>名利。例如，输出一个”hello docker”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker run ubuntu echo &quot;hello docker&quot;</span><br><span class="line">hello docker</span><br></pre></td></tr></table></figure><p>这跟在本次执行<code>echo &quot;hello docker&quot;</code>几乎没有任何区别，但是在执行<code>docker run</code>命令时经历了复杂的操作：</p><ul><li>检查本地是否存在指定的镜像，，不存在就从共有仓库下载</li><li>利用镜像创建并启动一个容器</li><li>分配一个文件系统给容器，并在只读的镜像层外面挂在一个可读写层</li><li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中</li><li>从王桥的地址池中配置一个IP地址给容器</li><li>执行用户指定的应用程序</li><li>执行完毕后容器自动终止</li></ul><p><code>docker run -d</code>命令会让容器在后台运行<br><code>docker logs</code>名利可以查看容器日志</p><h3 id="终止容器"><a href="#终止容器" class="headerlink" title="终止容器"></a>终止容器</h3><p>使用<code>docker stop 容器名或容器ID</code>命令停止一个容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost html]# docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                NAMES</span><br><span class="line">16555d4ebdf0        nginx:1.10.0        &quot;nginx -g &apos;daemon off&quot;   47 minutes ago      Up 8 seconds        0.0.0.0:80-&gt;80/tcp   jolly_goodall</span><br><span class="line">[root@localhost html]# docker stop 16555d4ebdf0 或者 docker stop jolly_goodall</span><br></pre></td></tr></table></figure><blockquote><p>docker stop命令首先想容器发送SIGKILL的信号，等待一段时间后（默认10秒）在发送SIGKILL信号来终止容器<br>docker kill 命令会直接发送SIGKILL信号来终止容器</p></blockquote><p>终止的容器可以使用<code>docer start</code>来启动一个容器</p><p>运行着的容器可以使用<code>docker restart</code>来重启容器</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;容器是Docker的另一个核心概念，简单来说容器就是镜像的一个运行示例。&lt;br&gt;
    
    </summary>
    
      <category term="docker" scheme="https://renguangli.com/categories/docker/"/>
    
    
      <category term="docker" scheme="https://renguangli.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker入门之镜像</title>
    <link href="https://renguangli.com/article/docker-image.html"/>
    <id>https://renguangli.com/article/docker-image.html</id>
    <published>2017-09-13T13:45:25.000Z</published>
    <updated>2017-09-21T03:19:07.781Z</updated>
    
    <content type="html"><![CDATA[<p>docker镜像类似于虚拟机镜像，可以将它理解为一个只读的模板。例如，一个镜像可以包含一个基本的操作系统，里面安装了tomcat(或者其它软件)，我们把它称为tomcat镜像。镜像是创建docker容器的基础。通过版本管理和增量的文件系统，docker提供了十分简单的机制来创建和更新的现有的镜像，也可以从镜像仓库里pull镜像，就像git  pull代码一样。<br><a id="more"></a></p><h4 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h4><p>镜像是容器运行的前提条件，<a href="https://hub.docker.com/" target="_blank" rel="noopener">官方Docker Hub</a> 镜像仓库提供了10W+个镜像提供大家开放下载。我们可以直接使用<code>docker pull</code>命令直接从Docker Hub镜像源下载镜像<br>命令格式：<code>docker pull name:tag</code>name为镜像名称，tag为镜像的标签(通常用来表示版本信息)\<br>获取一个Ubuntu 14.04系统镜像可以使用<code>docker pull ubuntu:14.04</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker pull ubuntu:14.04</span></span><br></pre></td></tr></table></figure></p><p>如果不指定tag，则默认会选择latest标签，下载仓库中最新版本的镜像。<br>严格地讲仓库名称还要添加镜像地址(即registry，注册服务器）为前缀，我们使用的是官方Docker Hub，所以前缀可以省略,完整命令为docker pull <code>docker.io/library/ubuntu:14.04</code><br>如果下载非官方的镜像，仓库名称前要指定完整的仓库地址。例如我们从网易的镜像源下载ubuntu 14.04 正确命令为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull hub.c.163.com/ubuntu:latest</span><br></pre></td></tr></table></figure><p>pull子命令支持的选项主要包括<code>-a, --all-tags=true|false</code> 是否获取从那个库中的所有镜像，默认为false，具体的选项可以通过 <code>docker pull --help</code> 命令查看。有了镜像后，我们就可以以这个镜像为基础启动一个容器来运行。以上面的 ubuntu:14.04 为例，如果我们打算启动里面的 bash 并且进行交互式操作的话，可以执行下面的命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker run -it --rm ubuntu:14.04 bash</span><br><span class="line">root@21762fe64d8f:/# cat /etc/os-release </span><br><span class="line">NAME=&quot;Ubuntu&quot;</span><br><span class="line">VERSION=&quot;14.04.5 LTS, Trusty Tahr&quot;</span><br><span class="line">ID=ubuntu</span><br><span class="line">ID_LIKE=debian</span><br><span class="line">PRETTY_NAME=&quot;Ubuntu 14.04.5 LTS&quot;</span><br><span class="line">VERSION_ID=&quot;14.04&quot;</span><br><span class="line">HOME_URL=&quot;http://www.ubuntu.com/&quot;</span><br><span class="line">SUPPORT_URL=&quot;http://help.ubuntu.com/&quot;</span><br><span class="line">BUG_REPORT_URL=&quot;http://bugs.launchpad.net/ubuntu/&quot;</span><br><span class="line">root@21762fe64d8f:/# exit</span><br><span class="line">exit</span><br><span class="line">[root@localhost ~]#</span><br></pre></td></tr></table></figure><p>docker run 就是运行容器的命令，我们这里简要的说明一下上面用到的参数。<br><code>-it</code>：这是两个参数，一个是 <code>-i</code>：交互式操作，一个是 <code>-t</code> 终端。我们这里打算进入 bash 执行一些命令并查看返回结果，因此我们需要交互式终端。<code>--rm</code>：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 <code>docker rm</code> 我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用 <code>--rm</code> 可以避免浪费空间。<br>ubuntu:14.04：这是指用 ubuntu:14.04 镜像为基础来启动容器。<br>bash：放在镜像名后的命令，这里我们希望有个交互式 Shell，因此用的是 bash。<br>进入容器后，我们可以在 Shell 下操作，执行任何所需的命令。这里，我们执行了 <code>cat /etc/os-release</code>，这是 Linux 常用的查看当前系统版本的命令，从返回的结果可以看到容器内是 Ubuntu 14.04.5 LTS 系统。最后我们通过 <code>exit</code> 退出了这个容器。</p><h3 id="查看镜像信息"><a href="#查看镜像信息" class="headerlink" title="查看镜像信息"></a>查看镜像信息</h3><h6 id="使用docker-images命令可以查看本地已存在镜像"><a href="#使用docker-images命令可以查看本地已存在镜像" class="headerlink" title="使用docker images命令可以查看本地已存在镜像"></a>使用<code>docker images</code>命令可以查看本地已存在镜像</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker images </span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">docker.io/ubuntu    14.04               ccc7a11d65b1        4 weeks ago         120.1 MB</span><br><span class="line">docker.io/ubuntu    latest              ccc7a11d65b1        4 weeks ago         120.1 MB</span><br></pre></td></tr></table></figure><p>在列出的信息中有5个字段，分别是镜像来自哪个仓库、标签、镜像ID、创建时间。</p><ul><li><code>docker images -a</code>列出所有镜像文件</li><li><code>docker images -q</code>仅列出镜像ID</li><li><code>docker images -f dangling=true</code>列出没有别使用的镜像</li></ul><h6 id="使用docker-tag命令添加镜像标签"><a href="#使用docker-tag命令添加镜像标签" class="headerlink" title="使用docker tag命令添加镜像标签"></a>使用<code>docker tag</code>命令添加镜像标签</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker tag ubuntu:14.04 ubuntu:14</span><br></pre></td></tr></table></figure><p>然后使用<code>docker images</code>查看镜像,多了一个拥有ubuntu:14标签的镜像<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker images </span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">docker.io/ubuntu    14                  ccc7a11d65b1        4 weeks ago         120.1 MB</span><br><span class="line">docker.io/ubuntu    14.04               ccc7a11d65b1        4 weeks ago         120.1 MB</span><br><span class="line">docker.io/ubuntu    latest              ccc7a11d65b1        4 weeks ago         120.1 MB</span><br></pre></td></tr></table></figure></p><h6 id="使用docker-inspect命令查看镜像详细信息。包括制作者、适应架构、各层的数字摘要等。信息比较多就不放出来了"><a href="#使用docker-inspect命令查看镜像详细信息。包括制作者、适应架构、各层的数字摘要等。信息比较多就不放出来了" class="headerlink" title="使用docker inspect命令查看镜像详细信息。包括制作者、适应架构、各层的数字摘要等。信息比较多就不放出来了"></a>使用<code>docker inspect</code>命令查看镜像详细信息。包括制作者、适应架构、各层的数字摘要等。信息比较多就不放出来了</h6><h6 id="使用docker-history-name-tag查看镜像历史"><a href="#使用docker-history-name-tag查看镜像历史" class="headerlink" title="使用docker history name:tag查看镜像历史"></a>使用<code>docker history name:tag</code>查看镜像历史</h6><p>比如查看<code>ubuntu:latest</code>镜像的创建过程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@yangjian06 wso2am]# docker history ubuntu:latest</span><br><span class="line">IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT</span><br><span class="line">ccc7a11d65b1        5 weeks ago         /bin/sh -c #(nop)  CMD [&quot;/bin/bash&quot;]            0 B                 </span><br><span class="line">&lt;missing&gt;           5 weeks ago         /bin/sh -c mkdir -p /run/systemd &amp;&amp; echo &apos;doc   7 B                 </span><br><span class="line">&lt;missing&gt;           5 weeks ago         /bin/sh -c sed -i &apos;s/^#\s*\(deb.*universe\)$/   2.759 kB            </span><br><span class="line">&lt;missing&gt;           5 weeks ago         /bin/sh -c rm -rf /var/lib/apt/lists/*          0 B                 </span><br><span class="line">&lt;missing&gt;           5 weeks ago         /bin/sh -c set -xe   &amp;&amp; echo &apos;#!/bin/sh&apos; &gt; /u   745 B               </span><br><span class="line">&lt;missing&gt;           5 weeks ago         /bin/sh -c #(nop) ADD file:39d3593ea220e686d5   120.1 MB</span><br></pre></td></tr></table></figure></p><p>过长的命令被截断了，可以使用<code>--no-trunc</code>选项输出完整命令</p><h3 id="搜索镜像"><a href="#搜索镜像" class="headerlink" title="搜索镜像"></a>搜索镜像</h3><p>使用<code>docker search</code>命令可以搜索镜像库里中共享的镜像，默认搜索官方仓库的镜像。比如我们搜索nginx镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@yangjian06 wso2am]# docker search -s 40 nginx</span><br><span class="line">INDEX       NAME                                               DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED</span><br><span class="line">docker.io   docker.io/nginx                                    Official build of Nginx.                        6865      [OK]       </span><br><span class="line">docker.io   docker.io/jwilder/nginx-proxy                      Automated Nginx reverse proxy for docker c...   1124                 [OK]</span><br><span class="line">docker.io   docker.io/richarvey/nginx-php-fpm                  Container running Nginx + PHP-FPM capable ...   439                  [OK]</span><br><span class="line">docker.io   docker.io/jrcs/letsencrypt-nginx-proxy-companion   LetsEncrypt container to use with nginx as...   223                  [OK]</span><br><span class="line">docker.io   docker.io/kong                                     Open-source Microservice &amp; API Management ...   112       [OK]       </span><br><span class="line">docker.io   docker.io/webdevops/php-nginx                      Nginx with PHP-FPM                              90                   [OK]</span><br><span class="line">docker.io   docker.io/kitematic/hello-world-nginx              A light-weight nginx container that demons...   85</span><br></pre></td></tr></table></figure><p>输出结果将按照星级评级进行排训，<code>-s</code>参数表示星级40以上的nginx镜像，支持的参数还有</p><ul><li><code>--automated=true|false</code> 仅显示自动创建的镜像，默认为否</li><li><code>--no-trunc=true|false</code> 输出信息不截断提示，默认为否<h3 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h3><h6 id="使用标签删除镜像，命令docker-rmi可以删除镜像"><a href="#使用标签删除镜像，命令docker-rmi可以删除镜像" class="headerlink" title="使用标签删除镜像，命令docker rmi可以删除镜像"></a>使用标签删除镜像，命令<code>docker rmi</code>可以删除镜像</h6>例如我们删除ubuntu:14镜像</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker rmi ubuntu:14</span><br><span class="line">Untagged: ubuntu:14</span><br></pre></td></tr></table></figure><p>如果该镜像有多个标签的话删除的只是标签并不会删除镜像。如果只有一个标签的话<code>docker rmi</code>命令会彻底删除镜像。</p><h6 id="使用id删除镜像"><a href="#使用id删除镜像" class="headerlink" title="使用id删除镜像"></a>使用id删除镜像</h6><p>使用命令<code>docker rmi ID</code>命令可以删除镜像</p><blockquote><p>当有该镜像创建的容器存在时，镜像是无法删除的。如果要强行删除的话可以使用<code>docker rmi -f ID</code></p></blockquote><h3 id="创建镜像"><a href="#创建镜像" class="headerlink" title="创建镜像"></a>创建镜像</h3><p>创建镜像的方法主要有三种：基于已有镜像的容器创建，基于本地模板导入，基于dockerfile创建</p><h6 id="基于已有镜像的容器创建"><a href="#基于已有镜像的容器创建" class="headerlink" title="基于已有镜像的容器创建"></a>基于已有镜像的容器创建</h6><p>该方法主要是用<code>docker commit</code>命令创建镜像，主要参数为</p><ul><li>-a，–auther=”” 作者信息</li><li>-m, –message=”” 提交信息</li></ul><p>首先我们启动一个nginx镜像,然后进入容器，创建一个test文件，退出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker run -d -p 80:80 nginx</span><br><span class="line">00fb093d0ec2044f6a5d62fe2aa64c487e427456bd53cb6dc8b6462be4e25167</span><br><span class="line">[root@localhost ~]# docker exec -it 00fb093d0 bash </span><br><span class="line">root@00fb093d0ec2:/# touch test</span><br><span class="line">root@00fb093d0ec2:/# exit</span><br><span class="line">[root@localhost ~]#</span><br></pre></td></tr></table></figure><p>这时容器已发生了改变，使用<code>docker commit</code>命令创建一个新的镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker commit -a rgl -m &quot;add a new file&quot;    00fb093d0ec2  test:0.1</span><br><span class="line">sha256:bcaa64525c2bde4e1329f7b28bc2c98b2947f83a5cb0efff6e9d968a85618930</span><br></pre></td></tr></table></figure><p>创建成功的话会返回新镜像的id。</p><h3 id="存出和载入镜像"><a href="#存出和载入镜像" class="headerlink" title="存出和载入镜像"></a>存出和载入镜像</h3><p>如果要存出镜像到本地文件，可以使用<code>docker save</code>命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker save -o nginx.tar nginx:latest</span><br></pre></td></tr></table></figure><p>这样就可以通过复制该镜像文件分享给其他人<br>如果要把镜像文件载入到本地镜像库，使用命令<code>docker load</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker load --input nginx.tar </span><br><span class="line">Loaded image: nginx:latest</span><br></pre></td></tr></table></figure><p>或者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker load &lt; nginx.tar </span><br><span class="line">Loaded image: nginx:latest</span><br></pre></td></tr></table></figure></p><h3 id="上传镜像"><a href="#上传镜像" class="headerlink" title="上传镜像"></a>上传镜像</h3><p>使用<code>docker push</code>命令上传镜像到仓库，默认上传到Docker官方仓库（需要登录）。例如我们自制的nginx：1.10.0镜像上传，首先我们要添加新的标签user/nginx:1.10.0 ,然后用<code>docker push</code>上传镜像，user改成你的用户名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker push user/nginx:1.10.0</span><br><span class="line">The push refers to a repository [docker.io/user/nginx]</span><br><span class="line">110566462efa: Mounted from library/nginx </span><br><span class="line">305e2b6ef454: Mounted from library/nginx </span><br><span class="line">1.10.0: digest: sha256:d8565c25b654da69bc9b837a0dee713c988f0276e90564aa8fd12ebf4c2ff11e size: 948</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;docker镜像类似于虚拟机镜像，可以将它理解为一个只读的模板。例如，一个镜像可以包含一个基本的操作系统，里面安装了tomcat(或者其它软件)，我们把它称为tomcat镜像。镜像是创建docker容器的基础。通过版本管理和增量的文件系统，docker提供了十分简单的机制来创建和更新的现有的镜像，也可以从镜像仓库里pull镜像，就像git  pull代码一样。&lt;br&gt;
    
    </summary>
    
      <category term="docker" scheme="https://renguangli.com/categories/docker/"/>
    
    
      <category term="docker" scheme="https://renguangli.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker入门之安装</title>
    <link href="https://renguangli.com/article/docker-deploy.html"/>
    <id>https://renguangli.com/article/docker-deploy.html</id>
    <published>2017-09-12T13:49:12.000Z</published>
    <updated>2017-09-21T03:19:53.188Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Centos下安装docker"><a href="#Centos下安装docker" class="headerlink" title="Centos下安装docker"></a>Centos下安装docker</h3><p>系统要求：64为操作系统，内核版本至少为3.10\<br>docker目前支持Centos6.5及以后的版本<br><a id="more"></a></p><h5 id="yum安装"><a href="#yum安装" class="headerlink" title="yum安装"></a>yum安装</h5><p>执行以下添加docker的yum源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum-config-manager --add-repo    https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><p>对于centos7系统，Centos-Extras源中已经内置了docker，如果已经配置了Centos-Extras源,可以直接通过命令<code>yum install -y docker</code>安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y docker</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Centos下安装docker&quot;&gt;&lt;a href=&quot;#Centos下安装docker&quot; class=&quot;headerlink&quot; title=&quot;Centos下安装docker&quot;&gt;&lt;/a&gt;Centos下安装docker&lt;/h3&gt;&lt;p&gt;系统要求：64为操作系统，内核版本至少为3.10\&lt;br&gt;docker目前支持Centos6.5及以后的版本&lt;br&gt;
    
    </summary>
    
      <category term="docker" scheme="https://renguangli.com/categories/docker/"/>
    
    
      <category term="docker" scheme="https://renguangli.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker入门之简介</title>
    <link href="https://renguangli.com/article/docker-summary.html"/>
    <id>https://renguangli.com/article/docker-summary.html</id>
    <published>2017-09-10T13:52:28.000Z</published>
    <updated>2018-06-11T09:47:58.554Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是docker"><a href="#什么是docker" class="headerlink" title="什么是docker"></a>什么是docker</h3><p>Docker是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。Docker 最初是 dotCloud 公司创始人 Solomon Hykes 在法国期间发起的一个公司内部项目，它是基于 dotCloud 公司多年云服务技术的一次革新，并于 2013 年 3 月以 Apache 2.0 授权协议开源，主要项目代码在 GitHub 上进行维护。Docker 项目后来还加入了 Linux 基金会，并成立推动 开放容器联盟。<br><a id="more"></a><br>Docker 自开源后受到广泛的关注和讨论，至今其 GitHub 项目已经超过 3 万 6 千个星标和一万多个 fork。甚至由于 Docker 项目的火爆，在 2013 年底，dotCloud 公司决定改名为 Docker。Docker 最初是在 Ubuntu 12.04 上开发实现的；Red Hat 则从 RHEL 6.5 开始对 Docker 进行支持；Google 也在其 PaaS 产品中广泛应用 Docker。</p><p>Docker 使用 Google 公司推出的 Go 语言 进行开发实现，基于 Linux 内核的 cgroup，namespace，以及 AUFS 类的 Union FS 等技术，对进程进行封装隔离，属于 操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。最初实现是基于 LXC，从 0.7 以后开始去除 LXC，转而使用自行开发的 libcontainer，从 1.11 开始，则进一步演进为使用 runC 和 containerd。</p><p>Docker 在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护。使得 Docker 技术比虚拟机技术更为轻便、快捷。</p><p>下面的图片比较了 Docker 和传统虚拟化方式的不同之处。传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。<br><img src="/img/docker-summary/virtualization.png" alt="虚拟机"><br><img src="/img/docker-summary/virtualization.png" alt="dcoker"></p><h3 id="为什么要用docker"><a href="#为什么要用docker" class="headerlink" title="为什么要用docker"></a>为什么要用docker</h3><p>作为一种新兴的虚拟化方式，Docker 跟传统的虚拟化方式相比具有众多的优势。</p><h4 id="更高效的利用系统资源"><a href="#更高效的利用系统资源" class="headerlink" title="更高效的利用系统资源"></a>更高效的利用系统资源</h4><p>由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，Docker 对系统资源的利用率更高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。</p><h4 id="更快速的启动时间"><a href="#更快速的启动时间" class="headerlink" title="更快速的启动时间"></a>更快速的启动时间</h4><p>传统的虚拟机技术启动应用服务往往需要数分钟，而 Docker 容器应用，由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。</p><h4 id="一致的运行环境"><a href="#一致的运行环境" class="headerlink" title="一致的运行环境"></a>一致的运行环境</h4><p>开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环境不一致，导致有些 bug 并未在开发过程中被发现。而 Docker 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 「这段代码在我机器上没问题啊」 这类问题。</p><h4 id="持续交付和部署"><a href="#持续交付和部署" class="headerlink" title="持续交付和部署"></a>持续交付和部署</h4><p>对开发和运维（DevOps）人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。<br>使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过 Dockerfile 来进行镜像构建，并结合 持续集成(Continuous Integration) 系统进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合 持续部署(Continuous Delivery/Deployment) 系统进行自动部署。<br>而且使用 Dockerfile 使镜像构建透明化，不仅仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需条件，帮助更好的生产环境中部署该镜像。</p><h4 id="更轻松的迁移"><a href="#更轻松的迁移" class="headerlink" title="更轻松的迁移"></a>更轻松的迁移</h4><p>由于 Docker 确保了执行环境的一致性，使得应用的迁移更加容易。Docker 可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。</p><h4 id="更轻松的维护和扩展"><a href="#更轻松的维护和扩展" class="headerlink" title="更轻松的维护和扩展"></a>更轻松的维护和扩展</h4><p>Docker 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。此外，Docker 团队同各个开源项目团队一起维护了一大批高质量的官方镜像，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本。</p><h4 id="对比传统虚拟机总结"><a href="#对比传统虚拟机总结" class="headerlink" title="对比传统虚拟机总结"></a>对比传统虚拟机总结</h4><table><thead><tr><th style="text-align:center">特性</th><th style="text-align:center">容器</th><th style="text-align:center">虚拟机</th></tr></thead><tbody><tr><td style="text-align:center">启动</td><td style="text-align:center">秒级</td><td style="text-align:center">分钟级</td></tr><tr><td style="text-align:center">硬盘使用</td><td style="text-align:center">一般为 MB</td><td style="text-align:center">一般为 GB</td></tr><tr><td style="text-align:center">性能</td><td style="text-align:center">接近原生</td><td style="text-align:center">弱于</td></tr><tr><td style="text-align:center">系统支持量</td><td style="text-align:center">单机支持上千个容器</td><td style="text-align:center">一般几十个</td></tr></tbody></table><blockquote><p>摘自 <a href="http://note.youdao.com/" target="_blank" rel="noopener">Docker — 从入门到实践</a><br><a href="https://baike.baidu.com/item/Docker/13344470?fr=aladdin" target="_blank" rel="noopener">百度百科</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;什么是docker&quot;&gt;&lt;a href=&quot;#什么是docker&quot; class=&quot;headerlink&quot; title=&quot;什么是docker&quot;&gt;&lt;/a&gt;什么是docker&lt;/h3&gt;&lt;p&gt;Docker是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。Docker 最初是 dotCloud 公司创始人 Solomon Hykes 在法国期间发起的一个公司内部项目，它是基于 dotCloud 公司多年云服务技术的一次革新，并于 2013 年 3 月以 Apache 2.0 授权协议开源，主要项目代码在 GitHub 上进行维护。Docker 项目后来还加入了 Linux 基金会，并成立推动 开放容器联盟。&lt;br&gt;
    
    </summary>
    
      <category term="docker" scheme="https://renguangli.com/categories/docker/"/>
    
    
      <category term="docker" scheme="https://renguangli.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>hexo之博客搭建</title>
    <link href="https://renguangli.com/article/hexo.html"/>
    <id>https://renguangli.com/article/hexo.html</id>
    <published>2016-10-07T10:58:25.000Z</published>
    <updated>2018-06-12T01:49:04.880Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是-Hexo？"><a href="#什么是-Hexo？" class="headerlink" title="什么是 Hexo？"></a>什么是 Hexo？</h3><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 <a href="https://daringfireball.net/projects/markdown/" target="_blank" rel="noopener">Markdown</a>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页，详情请看<a href="https://hexo.io/" target="_blank" rel="noopener">hexo官网</a>。<br>在使用之前电脑必须安装<a href="https://nodejs.org/" target="_blank" rel="noopener">nodejs</a>和<a href="https://git-scm.com/" target="_blank" rel="noopener">git</a><br><a id="more"></a></p><h3 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br><span class="line">$ hexo init blog</span><br><span class="line">$ <span class="built_in">cd</span> blog</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure><h3 id="创建新文章"><a href="#创建新文章" class="headerlink" title="创建新文章"></a>创建新文章</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"文章标题"</span></span><br></pre></td></tr></table></figure><p>如果文章标题之间有空格要用引号引起来</p><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>打开浏览器，在地址栏输入 localhost:4000就会出现如下界面</p><p><img src="https://https://blogs-1252211075.cos.ap-beijing.myqcloud.com/hexo.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;什么是-Hexo？&quot;&gt;&lt;a href=&quot;#什么是-Hexo？&quot; class=&quot;headerlink&quot; title=&quot;什么是 Hexo？&quot;&gt;&lt;/a&gt;什么是 Hexo？&lt;/h3&gt;&lt;p&gt;Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 &lt;a href=&quot;https://daringfireball.net/projects/markdown/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Markdown&lt;/a&gt;（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页，详情请看&lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;hexo官网&lt;/a&gt;。&lt;br&gt;在使用之前电脑必须安装&lt;a href=&quot;https://nodejs.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;nodejs&lt;/a&gt;和&lt;a href=&quot;https://git-scm.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;git&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="hexo" scheme="https://renguangli.com/categories/hexo/"/>
    
    
      <category term="hexo" scheme="https://renguangli.com/tags/hexo/"/>
    
  </entry>
  
</feed>
