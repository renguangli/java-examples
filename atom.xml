<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dali`s Blogs</title>
  
  <subtitle>大力的技术博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://renguangli.com/"/>
  <updated>2018-07-11T06:25:12.560Z</updated>
  <id>https://renguangli.com/</id>
  
  <author>
    <name>大力</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>DDOS攻击的防范教程</title>
    <link href="https://renguangli.com/article/ddos.html"/>
    <id>https://renguangli.com/article/ddos.html</id>
    <published>2018-07-11T06:24:23.000Z</published>
    <updated>2018-07-11T06:25:12.560Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>转载自 <a href="http://www.ruanyifeng.com/blog/2018/06/ddos.html" target="_blank" rel="noopener">阮一峰的网络日志</a></p></blockquote><p>一个多月前，阮一峰老师的个人网站遭受 DDOS 攻击，下线了50多个小时。这篇文章就来谈谈，如何应对这种攻击。</p><p>需要说明的是，我对 DDOS 并不精通，从没想过自己会成为攻击目标。攻击发生以后，很多素昧平生的朋友提供了各种帮助和建议，让我学到了很多东西。这里记录的就是对我最有帮助的一些解决方案。</p><p><img src="https://www.wangbase.com/blogimg/asset/201806/bg2018062601.jpg" alt="image"></p><h3 id="一、DDOS-是什么？"><a href="#一、DDOS-是什么？" class="headerlink" title="一、DDOS 是什么？"></a>一、DDOS 是什么？</h3><p>首先，我来解释一下，DDOS 是什么。</p><p>举例来说，我开了一家餐厅，正常情况下，最多可以容纳30个人同时进餐。你直接走进餐厅，找一张桌子坐下点餐，马上就可以吃到东西。</p><p><img src="https://www.wangbase.com/blogimg/asset/201806/bg2018062602.jpg" alt="image"></p><p>很不幸，我得罪了一个流氓。他派出300个人同时涌进餐厅。这些人看上去跟正常的顾客一样，每个都说”赶快上餐”。但是，餐厅的容量只有30个人，根本不可能同时满足这么多的点餐需求，加上他们把门口都堵死了，里三层外三层，正常用餐的客人根本进不来，实际上就把餐厅瘫痪了。</p><p><img src="https://www.wangbase.com/blogimg/asset/201806/bg2018062603.jpg" alt="image"></p><p>这就是 DDOS 攻击，它在短时间内发起大量请求，耗尽服务器的资源，无法响应正常的访问，造成网站实质下线</p><p>DDOS 里面的 DOS 是 denial of service（停止服务）的缩写，表示这种攻击的目的，就是使得服务中断。最前面的那个 D 是 distributed （分布式），表示攻击不是来自一个地方，而是来自四面八方，因此更难防。你关了前门，他从后门进来；你关了后门，他从窗口跳起来。</p><h3 id="二、DDOS-的种类"><a href="#二、DDOS-的种类" class="headerlink" title="二、DDOS 的种类"></a>二、DDOS 的种类</h3><p>DDOS 不是一种攻击，而是一大类攻击的总称。它有几十种类型，新的攻击方法还在不断发明出来。网站运行的各个环节，都可以是攻击目标。只要把一个环节攻破，使得整个流程跑不起来，就达到了瘫痪服务的目的。</p><p>其中，比较常见的一种攻击是 cc 攻击。它就是简单粗暴地送来大量正常的请求，超出服务器的最大承受量，导致宕机。我遭遇的就是 cc 攻击，最多的时候全世界大概20多个 IP 地址轮流发出请求，每个地址的请求量在每秒200次~300次。我看访问日志的时候，就觉得那些请求像洪水一样涌来，一眨眼就是一大堆，几分钟的时间，日志文件的体积就大了100MB。说实话，这只能算小攻击，但是我的个人网站没有任何防护，服务器还是跟其他人共享的，这种流量一来立刻就下线了。</p><p>本文以下的内容都是针对 cc 攻击。</p><h3 id="三、备份网站"><a href="#三、备份网站" class="headerlink" title="三、备份网站"></a>三、备份网站</h3><p>防范 DDOS 的第一步，就是你要有一个备份网站，或者最低限度有一个临时主页。生产服务器万一下线了，可以立刻切换到备份网站，不至于毫无办法。</p><p>备份网站不一定是全功能的，如果能做到全静态浏览，就能满足需求。最低限度应该可以显示公告，告诉用户，网站出了问题，正在全力抢修。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;转载自 &lt;a href=&quot;http://www.ruanyifeng.com/blog/2018/06/ddos.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;阮一峰的网络日志&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
      
    
    </summary>
    
    
      <category term="ddos" scheme="https://renguangli.com/tags/ddos/"/>
    
  </entry>
  
  <entry>
    <title>java基础-序列化与反序列化</title>
    <link href="https://renguangli.com/article/java-serializable.html"/>
    <id>https://renguangli.com/article/java-serializable.html</id>
    <published>2018-07-11T03:44:28.000Z</published>
    <updated>2018-07-11T04:01:26.989Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是序列化、反序列化？"><a href="#什么是序列化、反序列化？" class="headerlink" title="什么是序列化、反序列化？"></a>什么是序列化、反序列化？</h3><p>序列化是将对象转换为可传输格式的过程。 是一种数据的持久化手段。一般是以字节码或XML格式传输。而字节码或XML编码格式可以还原为完全相等的对象。这个相反的过程称为反序列化。</p><h3 id="有哪些应用场景。"><a href="#有哪些应用场景。" class="headerlink" title="有哪些应用场景。"></a>有哪些应用场景。</h3><p>一般广泛应用于网络传输，RMI和RPC等场景中。</p><h3 id="Java中如何实现序列化和反序列化。"><a href="#Java中如何实现序列化和反序列化。" class="headerlink" title="Java中如何实现序列化和反序列化。"></a>Java中如何实现序列化和反序列化。</h3><p>被序列化的类要实现Serializable或者Externalizable接口<br>当试图对一个对象进行序列化的时候，如果遇到不支持 Serializable 接口的对象。在此情况下，将抛出 NotSerializableException。</p><p>通过ObjectOutputStream和ObjectInputStream对对象进行序列化及反序列化</p><h3 id="序列化并不保存静态变量。"><a href="#序列化并不保存静态变量。" class="headerlink" title="序列化并不保存静态变量。"></a>序列化并不保存静态变量。</h3><h3 id="要想将父类对象也序列化，就需要让父类也实现Serializable-接口。"><a href="#要想将父类对象也序列化，就需要让父类也实现Serializable-接口。" class="headerlink" title="要想将父类对象也序列化，就需要让父类也实现Serializable 接口。"></a>要想将父类对象也序列化，就需要让父类也实现Serializable 接口。</h3><h3 id="Transient"><a href="#Transient" class="headerlink" title="Transient"></a>Transient</h3><p>关键字的作用是控制变量的序列化，在变量声明前加上该关键字，可以阻止该变量被序列化到文件中，在被反序列化后，transient 变量的值被设为初始值，如 int 型的是 0，对象型的是 null。</p><h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><p>服务器端给客户端发送序列化对象数据，对象中有一些数据是敏感的，比如密码字符串等，希望对该密码字段在序列化时，进行加密，而客户端如果拥有解密的密钥，只有在客户端进行反序列化时，才可以对密码进行读取，这样可以一定程度保证序列化对象的数据安全。</p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;什么是序列化、反序列化？&quot;&gt;&lt;a href=&quot;#什么是序列化、反序列化？&quot; class=&quot;headerlink&quot; title=&quot;什么是序列化、反序列化？&quot;&gt;&lt;/a&gt;什么是序列化、反序列化？&lt;/h3&gt;&lt;p&gt;序列化是将对象转换为可传输格式的过程。 是一种数据的持久化手
      
    
    </summary>
    
    
      <category term="java" scheme="https://renguangli.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>elasticsearch基础概念</title>
    <link href="https://renguangli.com/article/elasticsearch-base-concepts.html"/>
    <id>https://renguangli.com/article/elasticsearch-base-concepts.html</id>
    <published>2018-07-04T02:01:40.000Z</published>
    <updated>2018-07-12T07:11:51.698Z</updated>
    
    <content type="html"><![CDATA[<p>Elasticsearch是一个近乎实时的搜索平台</p><h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><p>群集是一个或多个节点（服务器）的集合，它们一起保存整个数据，并提供跨所有节点的联合索引和搜索功能。集群由默认名称为“elasticsearch”的唯一名称标识。此名称很重要，因为如果节点设置为通过名称加入群集，则节点只能成为群集的一部分。</p><p>确保不要在不同的环境中重复使用相同的群集名称，否则可能会导致节点加入错误的群集。例如，您可以使用logging-dev，logging-stage和logging-prod开发，分段和生产集群。</p><p>请注意，有一个只有一个节点的集群是完全正确的。此外，您还可能拥有多个独立的群集，每个群集都有自己的唯一群集名称。</p><h2 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h2><p>节点是属于集群一部分的单个服务器，存储数据并参与集群的索引和搜索功能。就像一个集群一样，一个节点由一个名称来标识，默认情况下该名称是在启动时分配给节点的随机通用唯一标识符（UUID）。如果您不需要默认值，您可以定义任何您想要的节点名称。此名称对于管理目的非常重要，您可以在其中识别网络中哪些服务器与Elasticsearch集群中的哪些节点相对应。</p><p>可以将节点配置为按集群名称加入特定集群。默认情况下，每个节点都设置为加入名为elasticsearch的集群，这意味着如果启动网络中的多个节点并假设他们可以发现其他节点，它们将自动形成并加入名为elasticsearch的单个集群。</p><p>在单个群集中，您可以拥有任意数量的节点。此外，如果您的网络上当前没有其他Elasticsearch节点正在运行，则默认情况下，启动单个节点将形成名为elasticsearch的新单节点集群。</p><h2 id="索引-index"><a href="#索引-index" class="headerlink" title="索引(index)"></a>索引(index)</h2><p>索引是一些具有相似特征的文档集合。例如，您可以拥有客户数据的索引，产品目录的另一个索引以及订单数据的另一个索引。索引由名称标识（必须全部小写），此名称用于在对其中的文档执行索引，搜索，更新和删除操作时引用索引。</p><p>在单个群集中，您可以根据需要定义任意数量的索引。</p><h2 id="类型-type"><a href="#类型-type" class="headerlink" title="类型(type)"></a>类型(type)</h2><p>一种类型，曾经是索引的逻辑类别/分区，允许您在同一索引中存储不同类型的文档，例如，一种类型用于用户，另一种类型用于博客帖子。不再可能在索引中创建多个类型，并且将在更高版本中删除类型的整个概念。</p><h2 id="Shards-amp-Replicas"><a href="#Shards-amp-Replicas" class="headerlink" title="Shards &amp; Replicas"></a>Shards &amp; Replicas</h2><p>索引可能潜在地存储大量数据，这些数据可能会超出单个节点的硬件限制。例如，占用1TB磁盘空间的十亿份文档的单个索引可能不适合单个节点的磁盘，或者可能太慢而无法单独向单个节点提供搜索请求。</p><p>为了解决这个问题，Elasticsearch提供了将索引细分为多个碎片的能力。当您创建索引时，您可以简单地定义所需的碎片数量。每个分片本身都是一个功能齐全且独立的“索引”，可以托管在集群中的任何节点上。</p><p>分片很重要，主要有两个原因：</p><p>它允许您水平分割/缩放内容量<br>它允许您跨越分片（可能在多个节点上）分发和并行化操作，从而提高性能/吞吐量<br>分片如何分布的机制以及其文档如何聚合回搜索请求完全由Elasticsearch管理，并且作为用户对您透明。</p><p>在可以随时发生故障的网络/云环境中，非常有用，强烈建议使用故障转移机制，以防分片/节点以某种方式脱机或因任何原因消失。为此，Elasticsearch允许您将索引碎片的一个或多个副本制作为简称为副本碎片或副本。</p><p>复制很重要，主要有两个原因：</p><p>它在碎片/节点失败的情况下提供高可用性。因此，请务必注意，副本分片永远不会在与从中复制的原始/主分片相同的节点上分配。<br>它允许您扩展搜索量/吞吐量，因为搜索可以在所有副本上并行执行。<br>总而言之，每个索引可以拆分为多个分片。索引也可以被复制为零（意味着没有副本）或更多次。一旦复制，每个索引将具有主分片（从中复制的原始分片）和副本分片（主分片的副本）。可以在创建索引时为每个索引定义分片和副本的数量。在创建索引之后，您可以随时更改动态副本的数量，但您无法在事后更改碎片的数量。</p><p>默认情况下，Elasticsearch中的每个索引都分配了5个主分片和1个副本，这意味着如果群集中至少有两个节点，则索引将包含5个主分片和另外5个副本分片（1个完整副本），总共每个索引10个碎片。</p><p>每个Elasticsearch分片都是一个Lucene索引。您可以在单个Lucene索引中拥有最大数量的文档。自LUCENE-5843起，限制为2,147,483,519（= Integer.MAX_VALUE - 128）个文件。您可以使用_cat / shards API监视分片大小。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Elasticsearch是一个近乎实时的搜索平台&lt;/p&gt;
&lt;h2 id=&quot;集群&quot;&gt;&lt;a href=&quot;#集群&quot; class=&quot;headerlink&quot; title=&quot;集群&quot;&gt;&lt;/a&gt;集群&lt;/h2&gt;&lt;p&gt;群集是一个或多个节点（服务器）的集合，它们一起保存整个数据，并提供跨所有节
      
    
    </summary>
    
    
      <category term="elasticsearch" scheme="https://renguangli.com/tags/elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>java8之Object源码阅读</title>
    <link href="https://renguangli.com/article/java8-Object.html"/>
    <id>https://renguangli.com/article/java8-Object.html</id>
    <published>2018-06-26T11:07:47.000Z</published>
    <updated>2018-07-12T07:12:02.226Z</updated>
    
    <content type="html"><![CDATA[<p>Object作为所有类的父类，还是有必要研究一下的。<br>Object类一共有以下几个方法<br><img src="https://rgl-1252211075.cos.ap-beijing.myqcloud.com/java/java8-Object.png" alt="image"><br>下面我们一个一个来看。</p><h2 id="clone"><a href="#clone" class="headerlink" title="clone()"></a>clone()</h2><p>clone方法是用来拷贝对象的，他是本地方法，由c++实现。clone方法只是浅拷贝，如果对象中包含了另一个复杂对象，clone出来的对象存在被修改的风险。</p><p>大家来看下面一个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义一个User类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    Node node;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(<span class="keyword">int</span> age, Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.node = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"User&#123;age="</span> + age + <span class="string">",node="</span> + node.name + <span class="string">"&#125;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> User <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (User) <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">    User user1 = <span class="keyword">new</span> User(<span class="keyword">new</span> Node(<span class="string">"张三"</span>), <span class="number">18</span>);</span><br><span class="line">    User user2 = user1.clone();</span><br><span class="line">    user2.node.name = <span class="string">"李四"</span>;</span><br><span class="line">    System.out.println(user1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果</p><blockquote><p>User{age=18,node=李四}</p></blockquote><p>看最后一行输出，当我们改变user2的node属性时，user1的node属性也改变了，说明clone方法只是拷贝了node属性的引用，实际上user1、user2的node属性指向的是堆内存中的同一个对象。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Object作为所有类的父类，还是有必要研究一下的。&lt;br&gt;Object类一共有以下几个方法&lt;br&gt;&lt;img src=&quot;https://rgl-1252211075.cos.ap-beijing.myqcloud.com/java/java8-Object.png&quot; alt
      
    
    </summary>
    
    
      <category term="java" scheme="https://renguangli.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>什么是JDK、JRE、JVM？</title>
    <link href="https://renguangli.com/article/jdk-jre-jvm.html"/>
    <id>https://renguangli.com/article/jdk-jre-jvm.html</id>
    <published>2018-06-14T09:54:52.000Z</published>
    <updated>2018-07-12T07:12:09.250Z</updated>
    
    <content type="html"><![CDATA[<p>下面贴一张图来看看他们之间的关系</p><p><img src="https://rgl-1252211075.cos.ap-beijing.myqcloud.com/java/jdk-jre-jvm.png" alt="JDK.JRE.JVM"></p><p>再看一张java官方更详细的结构图</p><p><img src="https://rgl-1252211075.cos.ap-beijing.myqcloud.com/java/java.png" alt="java组成结构"></p><h3 id="什么是jdk、jre、jvm？"><a href="#什么是jdk、jre、jvm？" class="headerlink" title="什么是jdk、jre、jvm？"></a>什么是jdk、jre、jvm？</h3><p><code>JDK</code>(Java Development Kit) 是Java语言的软件开发工具包，包含了一些开发工具JAVA运行时环境<code>JRE</code>。<br>jdk包含的开发工具有：</p><ul><li>javac – 编译器，将源程序转成字节码</li><li>jar – 打包工具，将相关的类文件打包成一个文件</li><li>javadoc – 文档生成器，从源码注释中提取文档</li><li>jdb – debugger，查错工具</li><li>java – 运行编译后的java程序（.class后缀的）</li><li>appletviewer：小程序浏览器，一种执行HTML文件上的Java小程序的Java浏览器。</li><li>Javah：产生可以调用Java过程的C过程，或建立能被Java程序调用的C过程的头文件。</li><li>Javap：Java反汇编器，显示编译类文件中的可访问功能和数据，同时显示字节代码含义。</li><li>console: Java进行系统调试和监控的工具<br>……</li></ul><p><code>jRE</code>（Java Runtime Environment，Java运行环境），包含JVM标准实现及Java核心类库。JRE是Java运行环境，如果你只想运行java程序，只需要安装JRE即可。</p><p><code>JVM</code>是Java Virtual Machine（Java虚拟机）的缩写，JVM是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。 java的一次编写、出处运行就是基于JVM实现的。</p><h3 id="JDK、JRE、JVM的用途"><a href="#JDK、JRE、JVM的用途" class="headerlink" title="JDK、JRE、JVM的用途"></a>JDK、JRE、JVM的用途</h3><p>JDK是用来开发java程序所必须的。</p><p>JRE是java程序运行所必须的。</p><p>JVM是用来加载class文件也是一次编写、处处运行的实现。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;下面贴一张图来看看他们之间的关系&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://rgl-1252211075.cos.ap-beijing.myqcloud.com/java/jdk-jre-jvm.png&quot; alt=&quot;JDK.JRE.JVM&quot;&gt;&lt;/p&gt;
&lt;p&gt;再看一张
      
    
    </summary>
    
    
      <category term="java" scheme="https://renguangli.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>每天学点儿linux--centos配置nginx-yum源</title>
    <link href="https://renguangli.com/article/nginx-yum.html"/>
    <id>https://renguangli.com/article/nginx-yum.html</id>
    <published>2018-05-21T03:15:31.000Z</published>
    <updated>2018-07-12T07:12:18.793Z</updated>
    
    <content type="html"><![CDATA[<p>创建/etc/yum.repos.d/nginx.repo文件，并添加一下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[nginx]</span><br><span class="line">name=nginx repo</span><br><span class="line">baseurl=http://nginx.org/packages/OS/OSRELEASE/$basearch/</span><br><span class="line">gpgcheck=0</span><br><span class="line">enabled=1</span><br></pre></td></tr></table></figure><p>将OS替换为“rhel” 或者 “centos”， “OSRELEASE”替换为7或6,取决与你的centos系统版本，6代表6.X版本，7代表7.X版本。替换完之后保存文件，然后就可以使用yum安装nignx了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install nginx</span><br></pre></td></tr></table></figure><p>参考资料<br><a href="http://nginx.org/en/linux_packages.html" target="_blank" rel="noopener">http://nginx.org/en/linux_packages.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;创建/etc/yum.repos.d/nginx.repo文件，并添加一下内容&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span
      
    
    </summary>
    
    
      <category term="nginx" scheme="https://renguangli.com/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>每天学点儿linux--centos7开放端口号</title>
    <link href="https://renguangli.com/article/centos-open-port.html"/>
    <id>https://renguangli.com/article/centos-open-port.html</id>
    <published>2018-05-15T11:44:20.000Z</published>
    <updated>2018-07-12T07:12:15.946Z</updated>
    
    <content type="html"><![CDATA[<p>开放80端口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=80/tcp --permanent</span><br></pre></td></tr></table></figure></p><p>命令含义：  </p><ul><li>–zone #作用域  </li><li>–add-port=80/tcp  #添加端口，格式为：端口/通讯协议  </li><li>–permanent  #永久生效，没有此参数重启后失效  </li></ul><p>关闭80端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd  --zone=public --remove-port=80/tcp --permanent</span><br></pre></td></tr></table></figure><p>查看防火墙状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status firewalld.service</span><br></pre></td></tr></table></figure><p>启动|关闭|重新启动  防火墙</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl [start|stop|restart] firewalld.service</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;开放80端口&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="每天学点儿linux" scheme="https://renguangli.com/tags/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E7%82%B9%E5%84%BFlinux/"/>
    
  </entry>
  
  <entry>
    <title>字节码指令集</title>
    <link href="https://renguangli.com/article/class.html"/>
    <id>https://renguangli.com/article/class.html</id>
    <published>2018-05-03T10:12:33.000Z</published>
    <updated>2018-07-12T07:12:12.823Z</updated>
    
    <content type="html"><![CDATA[<p>以下为字节码指令集，方便查看<br>nop 什么都不做<br>aconst_null 将null推送至栈顶<br>iconst_m1 将int型-1推送至栈顶<br>iconst_0 将int型0推送至栈顶<br>iconst_1 将int型1推送至栈顶<br>iconst_2 将int型2推送至栈顶<br>iconst_3 将int型3推送至栈顶<br>iconst_4 将int型4推送至栈顶<br>iconst_5 将int型5推送至栈顶<br>lconst_0 将long型0推送至栈顶<br>lconst_1 将long型1推送至栈顶<br>fconst_0 将float型0推送至栈顶<br>fconst_1 将float型1推送至栈顶<br>fconst_2 将float型2推送至栈顶<br>dconst_0 将do le型0推送至栈顶<br>dconst_1 将do le型1推送至栈顶<br>bipush 将单字节的常量值(-128~127)推送至栈顶<br>sipush 将一个短整型常量值(-32768~32767)推送至栈顶<br>ldc 将int, float或String型常量值从常量池中推送至栈顶<br>ldc_w 将int, float或String型常量值从常量池中推送至栈顶（宽索引）<br>ldc2_w 将long或do le型常量值从常量池中推送至栈顶（宽索引）<br>iload 将指定的int型本地变量<br>lload 将指定的long型本地变量<br>fload 将指定的float型本地变量<br>dload 将指定的do le型本地变量<br>aload 将指定的引用类型本地变量<br>iload_0 将第一个int型本地变量<br>iload_1 将第二个int型本地变量<br>iload_2 将第三个int型本地变量<br>iload_3 将第四个int型本地变量<br>lload_0 将第一个long型本地变量<br>lload_1 将第二个long型本地变量<br>lload_2 将第三个long型本地变量<br>lload_3 将第四个long型本地变量<br>fload_0 将第一个float型本地变量<br>fload_1 将第二个float型本地变量<br>fload_2 将第三个float型本地变量<br>fload_3 将第四个float型本地变量<br>dload_0 将第一个do le型本地变量<br>dload_1 将第二个do le型本地变量<br>dload_2 将第三个do le型本地变量<br>dload_3 将第四个do le型本地变量<br>aload_0 将第一个引用类型本地变量<br>aload_1 将第二个引用类型本地变量<br>aload_2 将第三个引用类型本地变量<br>aload_3 将第四个引用类型本地变量<br>iaload 将int型数组指定索引的值推送至栈顶<br>laload 将long型数组指定索引的值推送至栈顶<br>faload 将float型数组指定索引的值推送至栈顶<br>daload 将do le型数组指定索引的值推送至栈顶<br>aaload 将引用型数组指定索引的值推送至栈顶<br>baload 将boolean或byte型数组指定索引的值推送至栈顶<br>caload 将char型数组指定索引的值推送至栈顶<br>saload 将short型数组指定索引的值推送至栈顶<br>istore 将栈顶int型数值存入指定本地变量<br>lstore 将栈顶long型数值存入指定本地变量<br>fstore 将栈顶float型数值存入指定本地变量<br>dstore 将栈顶do le型数值存入指定本地变量<br>astore 将栈顶引用型数值存入指定本地变量<br>istore_0 将栈顶int型数值存入第一个本地变量<br>istore_1 将栈顶int型数值存入第二个本地变量<br>istore_2 将栈顶int型数值存入第三个本地变量<br>istore_3 将栈顶int型数值存入第四个本地变量<br>lstore_0 将栈顶long型数值存入第一个本地变量<br>lstore_1 将栈顶long型数值存入第二个本地变量<br>lstore_2 将栈顶long型数值存入第三个本地变量<br>lstore_3 将栈顶long型数值存入第四个本地变量<br>fstore_0 将栈顶float型数值存入第一个本地变量<br>fstore_1 将栈顶float型数值存入第二个本地变量<br>fstore_2 将栈顶float型数值存入第三个本地变量<br>fstore_3 将栈顶float型数值存入第四个本地变量<br>dstore_0 将栈顶do le型数值存入第一个本地变量<br>dstore_1 将栈顶do le型数值存入第二个本地变量<br>dstore_2 将栈顶do le型数值存入第三个本地变量<br>dstore_3 将栈顶do le型数值存入第四个本地变量<br>astore_0 将栈顶引用型数值存入第一个本地变量<br>astore_1 将栈顶引用型数值存入第二个本地变量<br>astore_2 将栈顶引用型数值存入第三个本地变量<br>astore_3 将栈顶引用型数值存入第四个本地变量<br>iastore 将栈顶int型数值存入指定数组的指定索引位置<br>lastore 将栈顶long型数值存入指定数组的指定索引位置<br>fastore 将栈顶float型数值存入指定数组的指定索引位置<br>dastore 将栈顶do le型数值存入指定数组的指定索引位置<br>aastore 将栈顶引用型数值存入指定数组的指定索引位置<br>bastore 将栈顶boolean或byte型数值存入指定数组的指定索引位置<br>castore 将栈顶char型数值存入指定数组的指定索引位置<br>sastore 将栈顶short型数值存入指定数组的指定索引位置<br>pop 将栈顶数值弹出 (数值不能是long或do le类型的)<br>pop2 将栈顶的一个（long或do le类型的)或两个数值弹出（其它）<br>dup 复制栈顶数值并将复制值压入栈顶<br>dup_x1 复制栈顶数值并将两个复制值压入栈顶<br>dup_x2 复制栈顶数值并将三个（或两个）复制值压入栈顶<br>dup2 复制栈顶一个（long或do   le类型的)或两个（其它）数值并将复制值压入栈顶<br>dup2_x1 dup_x1 指令的双倍版本<br>dup2_x2 dup_x2 指令的双倍版本<br>swap 将栈最顶端的两个数值互换(数值不能是long或do le类型的)<br>iadd 将栈顶两int型数值相加并将结果压入栈顶<br>ladd 将栈顶两long型数值相加并将结果压入栈顶<br>fadd 将栈顶两float型数值相加并将结果压入栈顶<br>dadd 将栈顶两do le型数值相加并将结果压入栈顶<br>is 将栈顶两int型数值相减并将结果压入栈顶<br>ls 将栈顶两long型数值相减并将结果压入栈顶<br>fs 将栈顶两float型数值相减并将结果压入栈顶<br>ds 将栈顶两do le型数值相减并将结果压入栈顶<br>imul 将栈顶两int型数值相乘并将结果压入栈顶<br>lmul 将栈顶两long型数值相乘并将结果压入栈顶<br>fmul 将栈顶两float型数值相乘并将结果压入栈顶<br>dmul 将栈顶两do le型数值相乘并将结果压入栈顶<br>idiv 将栈顶两int型数值相除并将结果压入栈顶<br>ldiv 将栈顶两long型数值相除并将结果压入栈顶<br>fdiv 将栈顶两float型数值相除并将结果压入栈顶<br>ddiv 将栈顶两do le型数值相除并将结果压入栈顶<br>irem 将栈顶两int型数值作取模运算并将结果压入栈顶<br>lrem 将栈顶两long型数值作取模运算并将结果压入栈顶<br>frem 将栈顶两float型数值作取模运算并将结果压入栈顶<br>drem 将栈顶两do le型数值作取模运算并将结果压入栈顶<br>ineg 将栈顶int型数值取负并将结果压入栈顶<br>lneg 将栈顶long型数值取负并将结果压入栈顶<br>fneg 将栈顶float型数值取负并将结果压入栈顶<br>dneg 将栈顶do le型数值取负并将结果压入栈顶<br>ishl 将int型数值左移位指定位数并将结果压入栈顶<br>lshl 将long型数值左移位指定位数并将结果压入栈顶<br>ishr 将int型数值右（符号）移位指定位数并将结果压入栈顶<br>lshr 将long型数值右（符号）移位指定位数并将结果压入栈顶<br>iushr 将int型数值右（无符号）移位指定位数并将结果压入栈顶<br>lushr 将long型数值右（无符号）移位指定位数并将结果压入栈顶<br>iand 将栈顶两int型数值作“按位与”并将结果压入栈顶<br>land 将栈顶两long型数值作“按位与”并将结果压入栈顶<br>ior 将栈顶两int型数值作“按位或”并将结果压入栈顶<br>lor 将栈顶两long型数值作“按位或”并将结果压入栈顶<br>ixor 将栈顶两int型数值作“按位异或”并将结果压入栈顶<br>lxor 将栈顶两long型数值作“按位异或”并将结果压入栈顶<br>iinc 将指定int型变量增加指定值（i++, i–, i+=2）<br>i2l 将栈顶int型数值强制转换成long型数值并将结果压入栈顶<br>i2f 将栈顶int型数值强制转换成float型数值并将结果压入栈顶<br>i2d 将栈顶int型数值强制转换成do le型数值并将结果压入栈顶<br>l2i 将栈顶long型数值强制转换成int型数值并将结果压入栈顶<br>l2f 将栈顶long型数值强制转换成float型数值并将结果压入栈顶<br>l2d 将栈顶long型数值强制转换成do le型数值并将结果压入栈顶<br>f2i 将栈顶float型数值强制转换成int型数值并将结果压入栈顶<br>f2l 将栈顶float型数值强制转换成long型数值并将结果压入栈顶<br>f2d 将栈顶float型数值强制转换成do le型数值并将结果压入栈顶<br>d2i 将栈顶do le型数值强制转换成int型数值并将结果压入栈顶<br>d2l 将栈顶do le型数值强制转换成long型数值并将结果压入栈顶<br>d2f 将栈顶do le型数值强制转换成float型数值并将结果压入栈顶<br>i2b 将栈顶int型数值强制转换成byte型数值并将结果压入栈顶<br>i2c 将栈顶int型数值强制转换成char型数值并将结果压入栈顶<br>i2s 将栈顶int型数值强制转换成short型数值并将结果压入栈顶<br>lcmp 比较栈顶两long型数值大小，并将结果（1，0，-1）压入栈顶<br>fcmpl 比较栈顶两float型数值大小，并将结果（1，0，-1）压入栈顶；当其中一个数值为NaN时，将-1压入栈顶<br>fcmpg 比较栈顶两float型数值大小，并将结果（1，0，-1）压入栈顶；当其中一个数值为NaN时，将1压入栈顶<br>dcmpl 比较栈顶两do   le型数值大小，并将结果（1，0，-1）压入栈顶；当其中一个数值为NaN时，将-1压入栈顶<br>dcmpg 比较栈顶两do le型数值大小，并将结果（1，0，-1）压入栈顶；当其中一个数值为NaN时，将1压入栈顶<br>ifeq 当栈顶int型数值等于0时跳转<br>ifne 当栈顶int型数值不等于0时跳转<br>iflt 当栈顶int型数值小于0时跳转<br>ifge 当栈顶int型数值大于等于0时跳转<br>ifgt 当栈顶int型数值大于0时跳转<br>ifle 当栈顶int型数值小于等于0时跳转<br>if_icmpeq 比较栈顶两int型数值大小，当结果等于0时跳转<br>if_icmpne 比较栈顶两int型数值大小，当结果不等于0时跳转<br>if_icmplt 比较栈顶两int型数值大小，当结果小于0时跳转<br>if_icmpge 比较栈顶两int型数值大小，当结果大于等于0时跳转<br>if_icmpgt 比较栈顶两int型数值大小，当结果大于0时跳转<br>if_icmple 比较栈顶两int型数值大小，当结果小于等于0时跳转<br>if_acmpeq 比较栈顶两引用型数值，当结果相等时跳转<br>if_acmpne 比较栈顶两引用型数值，当结果不相等时跳转<br>goto 无条件跳转<br>jsr 跳转至指定16位offset位置，并将jsr下一条指令地址压入栈顶<br>ret 返回至本地变量<br>tableswitch 用于switch条件跳转，case值连续（可变长度指令）<br>lookupswitch 用于switch条件跳转，case值不连续（可变长度指令<br>ireturn 从当前方法返回int<br>lreturn 从当前方法返回long<br>freturn 从当前方法返回float<br>dreturn 从当前方法返回do le<br>areturn 从当前方法返回对象引用<br>return 从当前方法返回void<br>getstatic 获取指定类的静态域，并将其值压入栈顶<br>putstatic 为指定的类的静态域赋值<br>getfield 获取指定类的实例域，并将其值压入栈顶<br>putfield 为指定的类的实例域赋值<br>invokevirtual 调用实例方法<br>invokespecial 调用超类构造方法，实例初始化方法，私有方法<br>invokestatic 调用静态方法<br>invokeinterface 调用接口方法<br>– 无此指令<br>new 创建一个对象，并将其引用值压入栈顶<br>newarray 创建一个指定原始类型（如int, float,   char…）的数组，并将其引用值压入栈顶<br>anewarray 创建一个引用型（如类，接口，数组）的数组，并将其引用值压入栈顶<br>arraylength 获得数组的长度值并压入栈顶<br>athrow 将栈顶的异常抛出<br>checkcast 检验类型转换，检验未通过将抛出ClassCastException<br>instanceof 检验对象是否是指定的类的实例，如果是将1压入栈顶，否则将0压入栈顶<br>monitorenter 获得对象的锁，用于同步方法或同步块<br>monitorexit 释放对象的锁，用于同步方法或同步块<br>wide &lt;待补充&gt;<br>multianewarray 创建指定类型和指定维度的多维数组（执行该指令时，操作栈中必须包含各维度的长度值），并将其引用值压入栈顶<br>ifnull 为null时跳转<br>ifnonnull 不为null时跳转<br>goto_w 无条件跳转（宽索引）<br>jsr_w 跳转至指定32位offset位置，并将jsr_w下一条指令地址压入栈顶</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;以下为字节码指令集，方便查看&lt;br&gt;nop 什么都不做&lt;br&gt;aconst_null 将null推送至栈顶&lt;br&gt;iconst_m1 将int型-1推送至栈顶&lt;br&gt;iconst_0 将int型0推送至栈顶&lt;br&gt;iconst_1 将int型1推送至栈顶&lt;br&gt;iconst
      
    
    </summary>
    
    
      <category term="java" scheme="https://renguangli.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>docker入门之镜像仓库</title>
    <link href="https://renguangli.com/article/88387b60-70b3-11e8-a0c3-3d78ce8af5d4.html"/>
    <id>https://renguangli.com/article/88387b60-70b3-11e8-a0c3-3d78ce8af5d4.html</id>
    <published>2017-11-02T10:27:13.000Z</published>
    <updated>2018-06-15T15:49:35.731Z</updated>
    
    <content type="html"><![CDATA[<p>docker仓库类似于代码仓库，它是docker集中存放镜像文件的场所</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;docker仓库类似于代码仓库，它是docker集中存放镜像文件的场所&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="docker" scheme="https://renguangli.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker入门之Dockerfile</title>
    <link href="https://renguangli.com/article/dockerfile.html"/>
    <id>https://renguangli.com/article/dockerfile.html</id>
    <published>2017-10-31T10:27:13.000Z</published>
    <updated>2018-07-12T07:11:27.065Z</updated>
    
    <content type="html"><![CDATA[<p>我们可以使用Dockerfile创建镜像，下面对Dockerfile指令进行简单介绍。</p><h3 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h3><p><code>FROM</code>指定基础镜像，若镜像不存在Docker会从docker hub中 来查找该镜像。<code>FROM</code>命令必须是Dockerfile的首个命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FROM centos:7.2.1511</span><br></pre></td></tr></table></figure><h3 id="MAINTAINER"><a href="#MAINTAINER" class="headerlink" title="MAINTAINER"></a>MAINTAINER</h3><p>维护者信息,一般用来指定作者,紧跟<code>FROM</code>命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MAINTAINER Ren Guangli &lt;renguangli@bonc.com.cn&gt;</span><br></pre></td></tr></table></figure><h3 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h3><p>Dockerfile中的<code>COPY</code>指令和<code>ADD</code>指令都可以将主机上的资源复制或加入到容器镜像中，都是在构建镜像的过程中完成的。<code>ADD</code>指令不仅能够将构建命令所在的主机本地的文件或目录，而且能够将远程URL所对应的文件或目录，作为资源复制到镜像文件系统。如果源文件是identity, gzip, bzip2，xz，tar.gz，tgz等类型的压缩文件，会添加tar -x命令，自动解压</p><blockquote><p>对于从远程URL获取资源的情况，由于ADD指令不支持认证，如果从远程获取资源需要认证，则只能使用RUN wget或RUN curl替代。<br>另外，如果源路径的资源发生变化，则该ADD指令将使Docker Cache失效，Dockerfile中后续的所有指令都不能使用缓存。因此尽量将ADD指令放在Dockerfile的后面。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># exec格式用法</span><br><span class="line">ADD [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;]</span><br><span class="line">ADD [&quot;hello.sh&quot;,&quot;docker.sh&quot;,&quot;/mnt&quot;]</span><br></pre></td></tr></table></figure><p>适合路径中带有空格的情况<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># shell格式用法</span><br><span class="line">ADD &lt;src&gt;... &lt;dest&gt;</span><br><span class="line">ADD hello.sh docker.sh /mnt</span><br></pre></td></tr></table></figure></p><p>注意事项</p><ul><li>源路径可以有多个</li><li>源路径是相对于执行build的相对路径</li><li>源路径如果是本地路径，必须是build上下文中的路径</li><li>源路径如果是一个目录，则该目录下的所有内容都将被加入到容器，但是该目录本身不会</li><li>目标路径必须是绝对路径，或相对于WORKDIR的相对路径</li><li>目标路径如果不存在，则会创建相应的完整路径</li><li>路径中可以使用通配符</li></ul><h3 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h3><p>和<code>ADD</code>指令类似，只是不能从远端获取资源和自动解压压缩文件</p><h3 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h3><p>配置环境变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENV &lt;key&gt; &lt;value&gt;</span><br><span class="line">ENV &lt;key&gt;=&lt;value&gt; ...</span><br></pre></td></tr></table></figure><p>第二种格式可以设置多个键值对，推荐在一条<code>ENV</code>指令中设置多个键值对，因为这样产生一个缓存层。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENV JAVA_HOME=/mnt/jdk1.7 PATH=$JAVA_HOME/bin:$PATH CLASSPATH=.:$JAVA_HOME/lib</span><br></pre></td></tr></table></figure><h3 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPOSE &lt;port&gt; [&lt;port&gt;...]</span><br></pre></td></tr></table></figure><p>指定于外界交互的端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPOSE 8080 443</span><br></pre></td></tr></table></figure><p>在容器启动时用-p传递参数，例如<code>docker run -d -p 8088:8080 -p 8089:443 tomcat:7.0.81</code>将容器内的8080绑定到本机的8088端口,443绑定到本机的8089端口</p><h3 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USER root</span><br></pre></td></tr></table></figure><p>指定运行容器时的用户名或 UID，后续的RUN、CMD、ENTRYPOINT也会使用指定用户。</p><h3 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WORKDIR /path/to/workdir</span><br></pre></td></tr></table></figure><p>为后续的RUN、CMD、ENTRYPOINT指令配置工作目录。可以使用多个WORKDIR指令，后续命令如果参数是相对路径，则会基于之前命令指定的路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">WORKDIR /a</span><br><span class="line">WORKDIR b</span><br><span class="line">WORKDIR c</span><br><span class="line">RUN pwd</span><br></pre></td></tr></table></figure><p>最终路径是/a/b/c。</p><p>WORKDIR指令可以在ENV设置变量之后调用环境变量:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENV DIRPATH /path</span><br><span class="line">WORKDIR $DIRPATH/$DIRNAME</span><br></pre></td></tr></table></figure><p>最终路径则为 <code>/path/$DIRNAME</code>。</p><h2 id="参考连接"><a href="#参考连接" class="headerlink" title="参考连接"></a>参考连接</h2><p><a href="http://www.docker.org.cn/dockerppt/114.html" target="_blank" rel="noopener">http://www.docker.org.cn/dockerppt/114.html</a><br><a href="http://www.cnblogs.com/sorex/p/6481407.html" target="_blank" rel="noopener">http://www.cnblogs.com/sorex/p/6481407.html</a><br><a href="http://blog.csdn.net/taiyangdao/article/details/73222601" target="_blank" rel="noopener">http://blog.csdn.net/taiyangdao/article/details/73222601</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们可以使用Dockerfile创建镜像，下面对Dockerfile指令进行简单介绍。&lt;/p&gt;
&lt;h3 id=&quot;FROM&quot;&gt;&lt;a href=&quot;#FROM&quot; class=&quot;headerlink&quot; title=&quot;FROM&quot;&gt;&lt;/a&gt;FROM&lt;/h3&gt;&lt;p&gt;&lt;code&gt;FROM&lt;
      
    
    </summary>
    
    
      <category term="docker" scheme="https://renguangli.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker入门之容器</title>
    <link href="https://renguangli.com/article/docker-container.html"/>
    <id>https://renguangli.com/article/docker-container.html</id>
    <published>2017-09-15T13:47:24.000Z</published>
    <updated>2018-07-12T07:11:31.571Z</updated>
    
    <content type="html"><![CDATA[<p>容器是docker的另一个核心概念，简单来说容器就是镜像的一个运行示例。</p><h3 id="查看容器"><a href="#查看容器" class="headerlink" title="查看容器"></a>查看容器</h3><p>使用<code>docker ps</code>命令查看运行着的容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker ps</span><br><span class="line">CONTAINER ID        IMAGE                  COMMAND                  CREATED             STATUS              PORTS                NAMES</span><br><span class="line">229929eb660f        renguangli/nginx:1.0   &quot;nginx -g &apos;daemon off&quot;   17 hours ago        Up 3 seconds        0.0.0.0:80-&gt;80/tcp   nginx</span><br></pre></td></tr></table></figure><p>使用<code>docker ps -a</code>命令查看所有的容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE                  COMMAND                  CREATED             STATUS              PORTS                NAMES</span><br><span class="line">229929eb660f        renguangli/nginx:1.0   &quot;nginx -g &apos;daemon off&quot;   17 hours ago        Up 3 seconds        0.0.0.0:80-&gt;80/tcp   nginx</span><br><span class="line">3ceb621f4aa9        jenkins             &quot;/bin/tini -- /usr/lo&quot;   About an hour ago   Exited (137) 48 seconds ago                            elated_davinci</span><br></pre></td></tr></table></figure><p>使用<code>docker ps -q</code>命令查看运行着的容器Id</p><p>使用<code>docker create image:tag name</code>命令创建一个容器并给容器一个name，例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker create nginx:latest nginx</span><br><span class="line">fd47cedfcce5cd2879ef65b342b1cd4130cbcc081cec532ff7af1744ad589116</span><br></pre></td></tr></table></figure><p>如果不加name的话随机分配一个名字</p><h3 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h3><p>使用<code>docker start 容器名称或容器ID</code>来启动一个容器，例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker ps -a</span><br><span class="line">229929eb660f        renguangli/nginx:1.0   &quot;nginx -g &apos;daemon off&quot;   17 hours ago        Exited (0) 8 seconds ago                        nginx</span><br><span class="line">[root@localhost ~]# docker start nginx 或者 docker start 229929eb660f</span><br></pre></td></tr></table></figure><h3 id="新建并启动容器"><a href="#新建并启动容器" class="headerlink" title="新建并启动容器"></a>新建并启动容器</h3><p>创建容器后可以用<code>docker start</code>命令启动容器，也可以用<code>docker run</code>命令直接新建并启动容器，<code>docker run</code>相当于先执行<code>docker create</code>命令在执行<code>docker start</code>名利。例如，输出一个”hello docker”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker run ubuntu echo &quot;hello docker&quot;</span><br><span class="line">hello docker</span><br></pre></td></tr></table></figure><p>这跟在本次执行<code>echo &quot;hello docker&quot;</code>几乎没有任何区别，但是在执行<code>docker run</code>命令时经历了复杂的操作：</p><ul><li>检查本地是否存在指定的镜像，，不存在就从共有仓库下载</li><li>利用镜像创建并启动一个容器</li><li>分配一个文件系统给容器，并在只读的镜像层外面挂在一个可读写层</li><li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中</li><li>从王桥的地址池中配置一个IP地址给容器</li><li>执行用户指定的应用程序</li><li>执行完毕后容器自动终止</li></ul><p><code>docker run -d</code>命令会让容器在后台运行<br><code>docker logs</code>名利可以查看容器日志<br><code>docker logs -f</code>命令可以像<code>tail -f</code>命令一样查看容器日志</p><h3 id="终止容器"><a href="#终止容器" class="headerlink" title="终止容器"></a>终止容器</h3><p>使用<code>docker stop 容器名或容器ID</code>命令停止一个容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost html]# docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                NAMES</span><br><span class="line">16555d4ebdf0        nginx:1.10.0        &quot;nginx -g &apos;daemon off&quot;   47 minutes ago      Up 8 seconds        0.0.0.0:80-&gt;80/tcp   jolly_goodall</span><br><span class="line">[root@localhost html]# docker stop 16555d4ebdf0 或者 docker stop jolly_goodall</span><br></pre></td></tr></table></figure><blockquote><p>docker stop命令首先想容器发送SIGKILL的信号，等待一段时间后（默认10秒）在发送SIGKILL信号来终止容器<br>docker kill 命令会直接发送SIGKILL信号来终止容器</p></blockquote><p>终止的容器可以使用<code>docer start</code>来启动一个容器</p><p>运行着的容器可以使用<code>docker restart</code>来重启容器</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;容器是docker的另一个核心概念，简单来说容器就是镜像的一个运行示例。&lt;/p&gt;
&lt;h3 id=&quot;查看容器&quot;&gt;&lt;a href=&quot;#查看容器&quot; class=&quot;headerlink&quot; title=&quot;查看容器&quot;&gt;&lt;/a&gt;查看容器&lt;/h3&gt;&lt;p&gt;使用&lt;code&gt;docker ps&lt;
      
    
    </summary>
    
    
      <category term="docker" scheme="https://renguangli.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker入门之镜像</title>
    <link href="https://renguangli.com/article/docker-image.html"/>
    <id>https://renguangli.com/article/docker-image.html</id>
    <published>2017-09-13T13:45:25.000Z</published>
    <updated>2018-07-12T07:11:47.490Z</updated>
    
    <content type="html"><![CDATA[<p>docker镜像类似于虚拟机镜像，可以将它理解为一个只读的模板。例如，一个镜像可以包含一个基本的操作系统，里面安装了tomcat(或者其它软件)，我们把它称为tomcat镜像。镜像是创建docker容器的基础。通过版本管理和增量的文件系统，docker提供了十分简单的机制来创建和更新的现有的镜像，也可以从镜像仓库里pull镜像，就像git  pull代码一样。</p><h2 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h2><p>镜像是容器运行的前提条件，<a href="https://hub.docker.com/" target="_blank" rel="noopener">官方DockerHub</a> 镜像仓库提供了很多个镜像提供大家开放下载。我们可以直接使用<code>docker pull</code>命令直接从Docker Hub镜像源下载镜像<br>命令格式：<code>docker pull name:tag</code>name为镜像名称，tag为镜像的标签(通常用来表示版本信息)\<br>获取一个Ubuntu 14.04系统镜像可以使用<code>docker pull ubuntu:14.04</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker pull ubuntu:14.04</span><br></pre></td></tr></table></figure></p><p>如果不指定tag，则默认会选择latest标签，下载仓库中最新版本的镜像。<br>严格地讲仓库名称还要添加镜像地址(即registry，注册服务器）为前缀，我们使用的是官方Docker Hub，所以前缀可以省略,完整命令为docker pull <code>docker.io/library/ubuntu:14.04</code><br>如果下载非官方的镜像，仓库名称前要指定完整的仓库地址。例如我们从网易的镜像源下载ubuntu 14.04 正确命令为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull hub.c.163.com/ubuntu:latest</span><br></pre></td></tr></table></figure><p>pull子命令支持的选项主要包括<code>-a, --all-tags=true|false</code> 是否获取从那个库中的所有镜像，默认为false，具体的选项可以通过 <code>docker pull --help</code> 命令查看。有了镜像后，我们就可以以这个镜像为基础启动一个容器来运行。以上面的 ubuntu:14.04 为例，如果我们打算启动里面的 bash 并且进行交互式操作的话，可以执行下面的命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker run -it --rm ubuntu:14.04 bash</span><br><span class="line">root@21762fe64d8f:/# cat /etc/os-release </span><br><span class="line">NAME=&quot;Ubuntu&quot;</span><br><span class="line">VERSION=&quot;14.04.5 LTS, Trusty Tahr&quot;</span><br><span class="line">ID=ubuntu</span><br><span class="line">ID_LIKE=debian</span><br><span class="line">PRETTY_NAME=&quot;Ubuntu 14.04.5 LTS&quot;</span><br><span class="line">VERSION_ID=&quot;14.04&quot;</span><br><span class="line">HOME_URL=&quot;http://www.ubuntu.com/&quot;</span><br><span class="line">SUPPORT_URL=&quot;http://help.ubuntu.com/&quot;</span><br><span class="line">BUG_REPORT_URL=&quot;http://bugs.launchpad.net/ubuntu/&quot;</span><br><span class="line">root@21762fe64d8f:/# exit</span><br><span class="line">exit</span><br><span class="line">[root@localhost ~]#</span><br></pre></td></tr></table></figure><p>docker run 就是运行容器的命令，我们这里简要的说明一下上面用到的参数。<br><code>-it</code>：这是两个参数，一个是 <code>-i</code>：交互式操作，一个是 <code>-t</code> 终端。我们这里打算进入 bash 执行一些命令并查看返回结果，因此我们需要交互式终端。<code>--rm</code>：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 <code>docker rm</code> 我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用 <code>--rm</code> 可以避免浪费空间。<br>ubuntu:14.04：这是指用 ubuntu:14.04 镜像为基础来启动容器。<br>bash：放在镜像名后的命令，这里我们希望有个交互式 Shell，因此用的是 bash。<br>进入容器后，我们可以在 Shell 下操作，执行任何所需的命令。这里，我们执行了 <code>cat /etc/os-release</code>，这是 Linux 常用的查看当前系统版本的命令，从返回的结果可以看到容器内是 Ubuntu 14.04.5 LTS 系统。最后我们通过 <code>exit</code> 退出了这个容器。</p><h2 id="查看镜像信息"><a href="#查看镜像信息" class="headerlink" title="查看镜像信息"></a>查看镜像信息</h2><p>使用<code>docker images</code>命令可以查看本地已存在镜像<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker images </span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">docker.io/ubuntu    14.04               ccc7a11d65b1        4 weeks ago         120.1 MB</span><br><span class="line">docker.io/ubuntu    latest              ccc7a11d65b1        4 weeks ago         120.1 MB</span><br></pre></td></tr></table></figure></p><p>在列出的信息中有5个字段，分别是镜像来自哪个仓库、标签、镜像ID、创建时间。</p><ul><li><code>docker images -a</code>列出所有镜像文件</li><li><code>docker images -q</code>仅列出镜像ID</li><li><code>docker images -f dangling=true</code>列出没有别使用的镜像</li></ul><p>使用<code>docker tag</code>命令给镜像添加新标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker tag ubuntu:14.04 ubuntu:14</span><br></pre></td></tr></table></figure><p>然后使用<code>docker images</code>查看镜像,多了一个拥有ubuntu:14标签的镜像<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker images </span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">docker.io/ubuntu    14                  ccc7a11d65b1        4 weeks ago         120.1 MB</span><br><span class="line">docker.io/ubuntu    14.04               ccc7a11d65b1        4 weeks ago         120.1 MB</span><br><span class="line">docker.io/ubuntu    latest              ccc7a11d65b1        4 weeks ago         120.1 MB</span><br></pre></td></tr></table></figure></p><p>使用<code>docker inspect</code>命令查看镜像详细信息。  包括制作者、适应架构、各层的数字摘要等等信息。</p><p>使用<code>docker history name:tag</code>查看镜像历史<br>比如查看<code>ubuntu:latest</code>镜像的创建过程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@yangjian06 wso2am]# docker history ubuntu:latest</span><br><span class="line">IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT</span><br><span class="line">ccc7a11d65b1        5 weeks ago         /bin/sh -c #(nop)  CMD [&quot;/bin/bash&quot;]            0 B                 </span><br><span class="line">&lt;missing&gt;           5 weeks ago         /bin/sh -c mkdir -p /run/systemd &amp;&amp; echo &apos;doc   7 B                 </span><br><span class="line">&lt;missing&gt;           5 weeks ago         /bin/sh -c sed -i &apos;s/^#\s*\(deb.*universe\)$/   2.759 kB            </span><br><span class="line">&lt;missing&gt;           5 weeks ago         /bin/sh -c rm -rf /var/lib/apt/lists/*          0 B                 </span><br><span class="line">&lt;missing&gt;           5 weeks ago         /bin/sh -c set -xe   &amp;&amp; echo &apos;#!/bin/sh&apos; &gt; /u   745 B               </span><br><span class="line">&lt;missing&gt;           5 weeks ago         /bin/sh -c #(nop) ADD file:39d3593ea220e686d5   120.1 MB</span><br></pre></td></tr></table></figure></p><p>过长的命令被截断了，可以使用<code>--no-trunc</code>选项输出完整命令</p><h2 id="搜索镜像"><a href="#搜索镜像" class="headerlink" title="搜索镜像"></a>搜索镜像</h2><p>使用<code>docker search</code>命令可以搜索镜像库里中共享的镜像，默认搜索官方仓库的镜像。比如我们搜索nginx镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@yangjian06 wso2am]# docker search -s 40 nginx</span><br><span class="line">INDEX       NAME                                               DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED</span><br><span class="line">docker.io   docker.io/nginx                                    Official build of Nginx.                        6865      [OK]       </span><br><span class="line">docker.io   docker.io/jwilder/nginx-proxy                      Automated Nginx reverse proxy for docker c...   1124                 [OK]</span><br><span class="line">docker.io   docker.io/richarvey/nginx-php-fpm                  Container running Nginx + PHP-FPM capable ...   439                  [OK]</span><br><span class="line">docker.io   docker.io/jrcs/letsencrypt-nginx-proxy-companion   LetsEncrypt container to use with nginx as...   223                  [OK]</span><br><span class="line">docker.io   docker.io/kong                                     Open-source Microservice &amp; API Management ...   112       [OK]       </span><br><span class="line">docker.io   docker.io/webdevops/php-nginx                      Nginx with PHP-FPM                              90                   [OK]</span><br><span class="line">docker.io   docker.io/kitematic/hello-world-nginx              A light-weight nginx container that demons...   85</span><br></pre></td></tr></table></figure><p>输出结果将按照星级评级进行排训，<code>-s</code>参数表示星级40以上的nginx镜像，支持的参数还有</p><ul><li><code>--automated=true|false</code> 仅显示自动创建的镜像，默认为否</li><li><code>--no-trunc=true|false</code> 输出信息不截断提示，默认为否<h2 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h2>命令<code>docker rmi</code>可以删除镜像<br>使用标签删除镜像，例如我们删除ubuntu:14镜像</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker rmi ubuntu:14</span><br><span class="line">Untagged: ubuntu:14</span><br></pre></td></tr></table></figure><p>如果该镜像有多个标签的话删除的只是标签并不会删除镜像。如果只有一个标签的话<code>docker rmi</code>命令会彻底删除镜像。  </p><h3 id="使用id删除镜像"><a href="#使用id删除镜像" class="headerlink" title="使用id删除镜像"></a>使用id删除镜像</h3><p>使用命令<code>docker rmi ID</code>命令可以删除镜像</p><blockquote><p>当有该镜像创建的容器存在时，镜像是无法删除的。如果要强行删除的话可以使用<code>docker rmi -f ID</code></p></blockquote><h2 id="创建镜像"><a href="#创建镜像" class="headerlink" title="创建镜像"></a>创建镜像</h2><p>创建镜像的方法主要有三种：基于已有镜像的容器创建，基于本地模板导入，<a href="https://renguangli.com/article/dockerfile.html">基于dockerfile创建镜像</a> </p><h3 id="基于已有镜像的容器创建"><a href="#基于已有镜像的容器创建" class="headerlink" title="基于已有镜像的容器创建"></a>基于已有镜像的容器创建</h3><p>该方法主要是用<code>docker commit</code>命令创建镜像，主要参数为</p><ul><li>-a，–auther=”” 作者信息</li><li>-m, –message=”” 提交信息</li></ul><p>首先我们启动一个nginx镜像,然后进入容器，创建一个test文件，退出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker run -d -p 80:80 nginx</span><br><span class="line">00fb093d0ec2044f6a5d62fe2aa64c487e427456bd53cb6dc8b6462be4e25167</span><br><span class="line">[root@localhost ~]# docker exec -it 00fb093d0 bash </span><br><span class="line">root@00fb093d0ec2:/# touch test</span><br><span class="line">root@00fb093d0ec2:/# exit</span><br><span class="line">[root@localhost ~]#</span><br></pre></td></tr></table></figure><p>这时容器已发生了改变，使用<code>docker commit</code>命令创建一个新的镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker commit -a rgl -m &quot;add a new file&quot;    00fb093d0ec2  test:0.1</span><br><span class="line">sha256:bcaa64525c2bde4e1329f7b28bc2c98b2947f83a5cb0efff6e9d968a85618930</span><br></pre></td></tr></table></figure><p>创建成功的话会返回新镜像的id。</p><h3 id="保存和加载镜像"><a href="#保存和加载镜像" class="headerlink" title="保存和加载镜像"></a>保存和加载镜像</h3><p>如果要存出镜像到本地文件，可以使用<code>docker save</code>命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker save -o nginx.tar nginx:latest</span><br></pre></td></tr></table></figure><p>这样就可以通过复制该镜像文件分享给其他人<br>如果要把镜像文件载入到本地镜像库，使用命令<code>docker load</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker load --input nginx.tar </span><br><span class="line">Loaded image: nginx:latest</span><br></pre></td></tr></table></figure><p>或者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker save nginx:latest &gt; nginx.tar </span><br><span class="line">Loaded image: nginx:latest</span><br><span class="line">[root@localhost ~]# docker load &lt; nginx.tar </span><br><span class="line">Loaded image: nginx:latest</span><br></pre></td></tr></table></figure></p><h3 id="上传镜像"><a href="#上传镜像" class="headerlink" title="上传镜像"></a>上传镜像</h3><p>使用<code>docker push</code>命令上传镜像到仓库，默认上传到Docker官方仓库（需要登录）。例如我们自制的nginx：1.10.0镜像上传，首先我们要添加新的标签user/nginx:1.10.0 ,然后用<code>docker push</code>上传镜像，user改成你的用户名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker push user/nginx:1.10.0</span><br><span class="line">The push refers to a repository [docker.io/user/nginx]</span><br><span class="line">110566462efa: Mounted from library/nginx </span><br><span class="line">305e2b6ef454: Mounted from library/nginx </span><br><span class="line">1.10.0: digest: sha256:d8565c25b654da69bc9b837a0dee713c988f0276e90564aa8fd12ebf4c2ff11e size: 948</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;docker镜像类似于虚拟机镜像，可以将它理解为一个只读的模板。例如，一个镜像可以包含一个基本的操作系统，里面安装了tomcat(或者其它软件)，我们把它称为tomcat镜像。镜像是创建docker容器的基础。通过版本管理和增量的文件系统，docker提供了十分简单的机制来
      
    
    </summary>
    
    
      <category term="docker" scheme="https://renguangli.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker入门之安装</title>
    <link href="https://renguangli.com/article/docker-deploy.html"/>
    <id>https://renguangli.com/article/docker-deploy.html</id>
    <published>2017-09-12T13:49:12.000Z</published>
    <updated>2018-07-12T07:11:29.559Z</updated>
    
    <content type="html"><![CDATA[<p>由于本人系统是centos,所以只演示在centos下的docke安装。其他系统请参考<a href="https://docs.docker.com/install/linux/docker-ce/centos/#set-up-the-repository" target="_blank" rel="noopener">docker官方文档</a></p><h3 id="Centos下安装docker"><a href="#Centos下安装docker" class="headerlink" title="Centos下安装docker"></a>Centos下安装docker</h3><p>系统要求：64为操作系统，内核版本至少为3.10<br>docker目前支持Centos6.5及以上的版本</p><h3 id="yum安装"><a href="#yum安装" class="headerlink" title="yum安装"></a>yum安装</h3><p>执行以下命令添加docker的yum源<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum-config-manager --add-repo    https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure></p><p>对于centos7，Centos-Extras源中已经内置了docker，可以直接通过yum安装<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y docker</span><br></pre></td></tr></table></figure></p><h3 id="启动docker"><a href="#启动docker" class="headerlink" title="启动docker"></a>启动docker</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker.service</span><br></pre></td></tr></table></figure><h3 id="设置docker开启自启动"><a href="#设置docker开启自启动" class="headerlink" title="设置docker开启自启动"></a>设置docker开启自启动</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemclt enable docker.service</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于本人系统是centos,所以只演示在centos下的docke安装。其他系统请参考&lt;a href=&quot;https://docs.docker.com/install/linux/docker-ce/centos/#set-up-the-repository&quot; target
      
    
    </summary>
    
    
      <category term="docker" scheme="https://renguangli.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker入门之简介</title>
    <link href="https://renguangli.com/article/docker-summary.html"/>
    <id>https://renguangli.com/article/docker-summary.html</id>
    <published>2017-09-10T13:52:28.000Z</published>
    <updated>2018-07-12T07:11:47.535Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是docker"><a href="#什么是docker" class="headerlink" title="什么是docker"></a>什么是docker</h2><ul><li>docker是一个开源的应用容器引擎;</li><li>docker是一个开源的软件部署解决方案；</li><li>docker也是轻量级的应用容器框架；</li><li>docker可以打包、发布、运行任何的应用。</li></ul><p>下面的图片比较了 docker 和传统虚拟化方式的不同之处。传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。</p><p><img src="https://rgl-1252211075.cos.ap-beijing.myqcloud.com/docker/docker.png" alt="虚拟机"><br><img src="https://rgl-1252211075.cos.ap-beijing.myqcloud.com/docker/virtualization.png" alt="dcoker"></p><h2 id="为什么要用docker"><a href="#为什么要用docker" class="headerlink" title="为什么要用docker"></a>为什么要用docker</h2><p>作为一种新兴的虚拟化方式，docker 跟传统的虚拟化方式相比具有众多的优势。</p><h3 id="更高效的利用系统资源"><a href="#更高效的利用系统资源" class="headerlink" title="更高效的利用系统资源"></a>更高效的利用系统资源</h3><p>由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，docker 对系统资源的利用率更高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。</p><h3 id="更快速的启动时间"><a href="#更快速的启动时间" class="headerlink" title="更快速的启动时间"></a>更快速的启动时间</h3><p>传统的虚拟机技术启动应用服务往往需要数分钟，而 docker 容器应用，由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。</p><h3 id="一致的运行环境"><a href="#一致的运行环境" class="headerlink" title="一致的运行环境"></a>一致的运行环境</h3><p>开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环境不一致，导致有些 bug 并未在开发过程中被发现。而 docker 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 「这段代码在我机器上没问题啊」 这类问题。</p><h3 id="持续交付和部署"><a href="#持续交付和部署" class="headerlink" title="持续交付和部署"></a>持续交付和部署</h3><p>对开发和运维（DevOps）人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。<br>使用 docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过 dockerfile 来进行镜像构建，并结合 持续集成(Continuous Integration) 系统进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合 持续部署(Continuous Delivery/Deployment) 系统进行自动部署。<br>而且使用 dockerfile 使镜像构建透明化，不仅仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需条件，帮助更好的生产环境中部署该镜像。</p><h3 id="更轻松的迁移"><a href="#更轻松的迁移" class="headerlink" title="更轻松的迁移"></a>更轻松的迁移</h3><p>由于 docker 确保了执行环境的一致性，使得应用的迁移更加容易。docker 可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。</p><h3 id="更轻松的维护和扩展"><a href="#更轻松的维护和扩展" class="headerlink" title="更轻松的维护和扩展"></a>更轻松的维护和扩展</h3><p>docker 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。此外，docker 团队同各个开源项目团队一起维护了一大批高质量的官方镜像，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本。</p><h3 id="对比传统虚拟机总结"><a href="#对比传统虚拟机总结" class="headerlink" title="对比传统虚拟机总结"></a>对比传统虚拟机总结</h3><table><thead><tr><th style="text-align:center">特性</th><th style="text-align:center">容器</th><th style="text-align:center">虚拟机</th></tr></thead><tbody><tr><td style="text-align:center">启动</td><td style="text-align:center">秒级</td><td style="text-align:center">分钟级</td></tr><tr><td style="text-align:center">硬盘使用</td><td style="text-align:center">一般为 MB</td><td style="text-align:center">一般为 GB</td></tr><tr><td style="text-align:center">性能</td><td style="text-align:center">接近原生</td><td style="text-align:center">弱于</td></tr><tr><td style="text-align:center">系统支持量</td><td style="text-align:center">单机支持上千个容器</td><td style="text-align:center">一般几十个</td></tr></tbody></table><blockquote><p><a href="https://baike.baidu.com/item/Docker/13344470?fr=aladdin" target="_blank" rel="noopener">百度百科</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是docker&quot;&gt;&lt;a href=&quot;#什么是docker&quot; class=&quot;headerlink&quot; title=&quot;什么是docker&quot;&gt;&lt;/a&gt;什么是docker&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;docker是一个开源的应用容器引擎;&lt;/li&gt;
&lt;li&gt;docker是
      
    
    </summary>
    
    
      <category term="docker" scheme="https://renguangli.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>hexo之博客搭建</title>
    <link href="https://renguangli.com/article/hexo.html"/>
    <id>https://renguangli.com/article/hexo.html</id>
    <published>2016-10-07T10:58:25.000Z</published>
    <updated>2018-07-12T07:11:56.452Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是-Hexo？"><a href="#什么是-Hexo？" class="headerlink" title="什么是 Hexo？"></a>什么是 Hexo？</h3><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 <a href="https://daringfireball.net/projects/markdown/" target="_blank" rel="noopener">Markdown</a>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页，详情请看<a href="https://hexo.io/" target="_blank" rel="noopener">hexo官网</a>。在使用之前电脑必须安装<a href="https://nodejs.org/" target="_blank" rel="noopener">nodejs</a>和<a href="https://git-scm.com/" target="_blank" rel="noopener">git</a></p><h3 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br><span class="line">$ hexo init blog</span><br><span class="line">$ <span class="built_in">cd</span> blog</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure><h3 id="创建新文章"><a href="#创建新文章" class="headerlink" title="创建新文章"></a>创建新文章</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"文章标题"</span></span><br></pre></td></tr></table></figure><p>如果文章标题之间有空格要用引号引起来</p><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>打开浏览器，在地址栏输入 localhost:4000就会出现如下界面</p><p><img src="/images/hexo.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;什么是-Hexo？&quot;&gt;&lt;a href=&quot;#什么是-Hexo？&quot; class=&quot;headerlink&quot; title=&quot;什么是 Hexo？&quot;&gt;&lt;/a&gt;什么是 Hexo？&lt;/h3&gt;&lt;p&gt;Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 &lt;a href=&quot;htt
      
    
    </summary>
    
    
      <category term="hexo" scheme="https://renguangli.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>每天学点儿linux--vi编辑器的使用</title>
    <link href="https://renguangli.com/article/linux-vi.html"/>
    <id>https://renguangli.com/article/linux-vi.html</id>
    <published>2016-08-15T11:42:19.000Z</published>
    <updated>2018-07-12T07:12:25.213Z</updated>
    
    <content type="html"><![CDATA[<p>vi编辑器是Linux系统下标准的编辑器，一般linux都没有桌面环境，平常修改一些配置文件，编写脚本对于vi编辑器来说都很方便，所以我们有必要学会并熟练使用它。<br>vi编辑器可以分为三种状态，分别是命令模式、插入模式和底行模式  </p><ul><li>命令行模式：控制屏幕光标的移动、字符、字或行的删除，移动复制某区段及进入插入模式下，或者到底行模式。   </li><li>插入模式：只有在插入模式下，才可以做文字输入，按「ESC」键可回到命令行模式。</li><li>底行模式：将文件保存或退出vi，也可以设置编辑环境，如寻找字符串、列出行号……等。 </li></ul><p>下面列举一些常用命令和技巧</p><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>我们如何进入vi编辑器呢？<br>输入<code>vi fileName</code>命令进入vi编辑器，这时处于命令行模式。<br>在命令模式下按下<code>i</code>字母就会进入插入模式，这时就可以对对文件进行编辑了。<br>那我们如何退出vi编辑器呢？<br>在命令行模式下，按一下 <code>:</code>冒号键进入底行模式</p><ul><li><code>:w</code>保存但不退出。</li><li><code>:w fileName</code>文件另存为filename。</li><li><code>:wq</code>保存并退出。</li><li><code>:q</code>退出但不保存。<br>在末尾加入<code>！</code>表示强制执行，例如<code>:q!</code>表示强制退出但不保存。</li></ul><h2 id="命令行模式功能键"><a href="#命令行模式功能键" class="headerlink" title="命令行模式功能键"></a>命令行模式功能键</h2><h3 id="进入插入模式的几种方法。"><a href="#进入插入模式的几种方法。" class="headerlink" title="进入插入模式的几种方法。"></a>进入插入模式的几种方法。</h3><ul><li>按<code>i</code>进入插入模式后，光标当前位置开始输入文件；</li><li>按大写<code>I</code>进入插入模式后，光标所在行开始位置开始输入文件</li><li>按<code>a</code>进入插入模式后，光标所在位置的下一个位置开始输入文字； </li><li>按<code>A</code>进入插入模式后，光标所在行末尾开始输入文字； </li><li>按<code>o</code>进入插入模式后，在当前行下一行插入新的一行，从行首开始输入文字。 </li><li>按<code>O</code>进入插入模式后，在当前行上一行是插入新的一行，从行首开始输入文字。</li></ul><h3 id="移动光标"><a href="#移动光标" class="headerlink" title="移动光标"></a>移动光标</h3><p>vi可以直接用键盘上的光标来上下左右移动，但正规的vi是用小写英文字母<code>hjkl</code>，分别控制光标左、下、上、右移一格。<br>其他移动光标的功能键</p><ul><li><code>ctrl + b</code>屏幕往“后”移动一页。 </li><li><code>ctrl + f</code>屏幕往“前”移动一页。 </li><li><code>ctrl + u</code>屏幕往“后”移动半页</li><li><code>ctrl + d</code>屏幕往“前”移动半页。</li><li><code>home</code>,<code>^</code>,<code>0</code>移到行首。</li><li><code>end</code>,<code>\$</code>移到行尾</li><li><code>gg</code>移到文件开头。</li><li><code>G</code>移到文件最后。</li><li><code>w</code>光标跳到下个字的开头 </li><li><code>e</code>光标跳到下个字的字尾 </li><li><code>b</code>光标回到上个字的开头 </li><li><code>#l</code>光标移到该行的第#个位置，如：5l,56l。 </li></ul><h3 id="删除文字"><a href="#删除文字" class="headerlink" title="删除文字"></a>删除文字</h3><ul><li><code>x</code>每按一次，删除光标所在位置的“后面”一个字符。 </li><li><code>#x</code>：例如，「6x」表示删除光标所在位置的“后面”6个字符。 </li><li><code>X</code>大写的X，每按一次，删除光标所在位置的“前面”一个字符。 </li><li><code>#X</code>例如，「20X」表示删除光标所在位置的“前面”20个字符。 </li><li><code>dd</code>删除光标所在行。 </li><li><code>#dd</code>从光标所在行开始删除#行 </li></ul><h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><ul><li><code>yw</code>将光标所在之处到字尾的字符复制到缓冲区中。 </li><li><code>#wy</code>复制#个字到缓冲区 </li><li><code>yy</code>复制光标所在行到缓冲区。 </li><li><code>#yy</code>例如，「6yy」表示拷贝从光标所在的该行“往下数”6行文字。 </li><li><code>p</code>将缓冲区内的字符贴到光标所在位置。注意：所有与“y”有关的复制命令都必须与“p”配合才能完成复制与粘贴功能。</li></ul><h3 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h3><ul><li><code>r</code>替换光标所在处的字符。 </li><li><code>R</code>替换光标所到之处的字符，直到按下「ESC」键为止。 </li></ul><h3 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h3><ul><li><code>u</code>如果您误执行一个命令，可以马上按下<code>u</code>，回到上一个操作。按多次“u”可以执行多次回复。 </li></ul><h3 id="更改"><a href="#更改" class="headerlink" title="更改"></a>更改</h3><ul><li><code>cw</code>更改光标所在处的字到字尾处 </li><li><code>c#w</code>例如,<code>c3w</code>表示更改3个字 </li></ul><h3 id="跳至指定的行"><a href="#跳至指定的行" class="headerlink" title="跳至指定的行"></a>跳至指定的行</h3><ul><li><code>ctrl + g</code>列出光标所在行的行号。 </li><li><code>#G</code>例如，<code>10G</code>，表示移动光标至文章的第15行行首。 </li></ul><h2 id="底行模式下命令简介"><a href="#底行模式下命令简介" class="headerlink" title="底行模式下命令简介"></a>底行模式下命令简介</h2><p>　　在使用底行模式之前，请记住先按「ESC」键确定您已经处于命令行模式下后，再按<code>:</code>冒号即可进入底行模式。 </p><h3 id="列出行号"><a href="#列出行号" class="headerlink" title="列出行号"></a>列出行号</h3><ul><li><code>set nu</code>输入<code>set nu</code>后，会在文件中的每一行前面列出行号。 </li></ul><h3 id="跳到文件中的某一行"><a href="#跳到文件中的某一行" class="headerlink" title="跳到文件中的某一行"></a>跳到文件中的某一行</h3><ul><li><code>#</code>号表示一个数字，在冒号后输入一个数字，再按回车键就会跳到该行了，如输入数字15，再回车，就会跳到文章的第15行。 </li></ul><h3 id="查找字符"><a href="#查找字符" class="headerlink" title="查找字符"></a>查找字符</h3><ul><li><code>/关键字</code>先按<code>/</code>键，再输入您想寻找的字符，如果第一次找的关键字不是您想要的，可以一直按<code>n</code>会往后寻找到您要的关键字为止。 </li><li><code>?关键字</code>先按<code>?</code>键，再输入您想寻找的字符，如果第一次找的关键字不是您想要的，可以一直按<code>n</code>会往前寻找到您要的关键字为止。 </li></ul><h3 id="保存文件"><a href="#保存文件" class="headerlink" title="保存文件"></a>保存文件</h3><ul><li><code>w</code>在冒号输入字母<code>w</code>就可以将文件保存起来。 </li></ul><h3 id="离开vi"><a href="#离开vi" class="headerlink" title="离开vi"></a>离开vi</h3><ul><li><code>q</code>按「q」就是退出，如果无法离开vi，可以在<code>q</code>跟一个<code>!</code>强制离开vi。 </li><li><code>qw</code>一般建议离开时，搭配<code>w</code>一起使用，这样在退出的时候还可以保存文件。 </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;vi编辑器是Linux系统下标准的编辑器，一般linux都没有桌面环境，平常修改一些配置文件，编写脚本对于vi编辑器来说都很方便，所以我们有必要学会并熟练使用它。&lt;br&gt;vi编辑器可以分为三种状态，分别是命令模式、插入模式和底行模式  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;命令行模式
      
    
    </summary>
    
    
      <category term="每天学点儿linux" scheme="https://renguangli.com/tags/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E7%82%B9%E5%84%BFlinux/"/>
    
  </entry>
  
</feed>
